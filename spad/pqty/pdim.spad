)abbrev category PUNIT PhysicalUnit
PhysicalUnit() : Category == with   
    "*"  : (%,%) -> %
    "/"  : (%,%) -> %
    "^"  : (%,Integer) -> %
    "="  : (%,%) -> Boolean
    dim  : % -> List Integer
    one  : %
    coerce : % -> OutputForm


)abbrev domain PUSYS PhysicalUnitSystem 
PhysicalUnitSystem(u:List Symbol) : Exports == Implementation where
    BASU ==> OrderedVariableList(u) 
    FAGB ==> FreeAbelianGroup(BASU) 
    Exports == Join(PhysicalUnit,CoercibleTo OutputForm) with
      _* : (%,%) -> %
      _/ : (%,%) -> %
      baseSymbols : List Symbol
      baseUnits : List %
      factors : % ->  List Record(gen: BASU,exp: Integer)
    Implementation == FreeGroup(BASU) add
      Rep:=FreeAbelianGroup(BASU)
      sort: % -> %
      x * y == sort(x+y) 
      x / y == sort(x-y)
      x ^ n == sort(n*x) 
      one() == 0$Rep
      baseSymbols() == [convert(x)@Symbol for x in enumerate$BASU]
      baseUnits() == [x::% for x in enumerate$BASU]
      dim(x) ==
        d:=[0@Integer for j in 1..#u]
        lr:List(Record(gen:BASU,exp:Integer)):=factors(x)
        for r in lr repeat
          g:BASU:=r.gen
          k:=position(g,enumerate$BASU)$List(BASU)
          d.k:=r.exp
        d

      x = y == test(dim x = dim y)
      
      coerce0(x:%):OutputForm ==
        size x = 0 => outputForm(1)
        d:=dim(x)
        b:=baseSymbols()
        y:List OutputForm:=[]
        for j in 1..#d repeat
          if d.j=1 then y:=concat(y,outputForm(b.j))
          else
            if d.j~=0 then y:=concat(y,outputForm(b.j)^outputForm(d.j))
        blankSeparate y 

      sort(x:%):% ==
        R==>Record(gen: BASU,exp: Integer)
        f:=(a:R,b:R):Boolean+->(test(a.gen>b.gen))
        sort(f,factors x) pretend Rep 


-- SI:=PUSYS(['m,'kg,'s])
-- u:=baseUnits()$SI
-- coerce0 works as coerce, if sort then not necess.
