)abbrev domain CMAP CellMap
++
CellMap(R,n) : Exports == Implementation where

  R: Join(Ring,Comparable)
  n: NonNegativeInteger
  
  X   ==> Expression R
  DP  ==> DirectProduct
  OF  ==> OutputForm
  NNI ==> NonNegativeInteger
  MAP ==> List X -> List X
  DOM ==> List(Segment X)

  Exports == Join(CoercibleTo OutputForm) with
  
    _= : (%,%) -> Boolean
  
    cellMap   : (DOM,MAP) -> %
    getDom    : % -> DOM
    getMap    : % -> MAP
    faceLo    : (%,NNI) -> %
    faceHi    : (%,NNI) -> %
    faces     : % -> List List(%)
    coerce    : % -> OutputForm

  Implementation ==  add 
    
    Rep := Record(d:DOM,f:MAP)
    
    (x:% = y:%):Boolean == 
      l:NNI:=min(#(x.d),#(y.d))
      v:List X
      for j in 1..l repeat
        s:X:=subscript('z,[j::OF])::X
        v:=concat(v,s::X)
      x.d =y.d and (x.f) v = (y.f) v => true
      false
    
    cellMap(d:DOM,f:MAP):% == 
      #d > n => error concat("#DOM > ",string n)
      v:List X:=[1::X for j in 1..#d]
      ~test(#f(v)=n) => error concat("#Range ~= ", string n) 
      construct(d,f)

    faceLo(x:%,i:NNI):% ==
      l:NNI:=#(x.d)
      v:List X
      for j in 1..l repeat
        if j=i then
          s:X:=lo(x.d.i)
        else
          s:X:=subscript('x,[j::OF])::X
        v:=concat(v,s::X)
      vv:=delete(v,i..i)
      d:List(Segment X):=delete(x.d,i..i)
      f:MAP:=vv+->(x.f) v
      cellMap(d,f)
      

    faceHi(x:%,i:NNI):% ==
      l:NNI:=#(x.d)
      v:List X
      for j in 1..l repeat
        if j=i then
          s:X:=hi(x.d.i)
        else
          s:X:=subscript('x,[j::OF])::X
        v:=concat(v,s::X)
      vv:=delete(v,i..i)
      d:List(Segment X):=delete(x.d,i..i)
      f:MAP:=vv+->(x.f) v
      cellMap(d,f)


    faces(x:%):List List(%) ==
      l:NNI:=#(x.d)
      [[faceLo(x,j), faceHi(x,j)] for j in 1..l]
        

    getDom(x) == x.d
    getMap(x) == x.f
      
      
    coerce(x) == 
      v:List X
      for j in 1..#(x.d) repeat
        s:X:=subscript('x,[j::OF])::X
        v:=concat(v,s::X)
      r:List X:=(x.f) v
      hconcat ["|",x.d::OF," -> ",r::OF,"|"]
  
    
      
   
)abbrev domain CNCX ChainComplex
++
ChainComplex(R,n) : Exports == Implementation where

  NNI ==> NonNegativeInteger
  INT ==> Integer
  
  n : NNI
  R : Join(Ring,Comparable)
  
  CMAP ==> CellMap(R,n)
  CTOF ==> CoercibleTo OutputForm
  X    ==> Expression R
  OF   ==> OutputForm

  Exports == Join(AbelianGroup ,CTOF, RetractableTo CMAP) with
 
    bdry : % -> %
    --coerce : % -> OutputForm
    
  Implementation == FreeAbelianGroup(CMAP) add

    Rep:=FreeAbelianGroup(CMAP)
      

    bdry(c:%):% == 
      if size(c) = 1 then
        s:=nthFactor(c,1)
        l:=faces(s)
        fs:=[(a.2::Rep-a.1::Rep) for a in l]
        sgn:=(j:INT):INT+->if even? (j-1) then 1 else -1
        nthCoef(c,1)*reduce("+",[sgn(j)*fs.j::Rep for j in 1..#fs])
      else
        ct:=[(nthCoef(c,j)*nthFactor(c,j))::Rep for j in 1..size(c)]
        reduce("+",map(bdry,ct))
        
    
-- g:=cellMap([a::X..b,c..d],Z+->[Z.1,Z.2,Z.2])$CellMap(INT,3)
-- f:=cellMap([a::X..b,c..d,0..1],Z+->[Z.1,Z.2,Z.2+Z.1])$CellMap(INT,3)
-- f:=f::ChainComplex(INT,3)
-- g:=g::ChainComplex(INT,3)
-- 2*f+g


     
