)abbrev domain CMAP CellMap
++
CellMap(R,n) : Exports == Implementation where

  R: Join(Ring,Comparable)
  n: NonNegativeInteger
  
  X   ==> Expression R
  DP  ==> DirectProduct
  OF  ==> OutputForm
  NNI ==> NonNegativeInteger
  MAP ==> List X -> List X
  DOM ==> List(Segment X)

  Exports == Join(CoercibleTo OutputForm,SetCategory) with
  
    _= : (%,%) -> Boolean
      ++ f1=f2 checks if two given cell maps are equal, that is if they have
      ++ the same domain D and the same mapping from D into X^n.
    cellMap : (DOM,MAP) -> %
      ++ cellMap(D,f) is the constructor. Usually one has to specify the
      ++ dimension of the target space. For example, let Q=[a..b,c..d], then
      ++ cellMap(Q,Z+->[sin(Z.1),cos(Z.2),Z.1*Z.2])$CMAP(INT,3) defines a
      ++ 2-surface in X^3.
    getDom : % -> DOM
      ++ getDom(f) extracts the domain of f.
    getMap : % -> MAP
      ++ getMap(f) extracts the map of f.
    faces  : % -> List List(%)
      ++ faces(f) returns the faces of f, that means the images of the boundary
      ++ of the domain. Note: the returned list contains pairs of faces 
      ++ corresponding to the endpoints of intervals.
    coerce : % -> OutputForm
      ++ coerce(f) gives the output representation.
    drawIfPossible : % -> Void
      ++ drawIfPossible(f) tries to draw the cellMap f using FriCAS' plotting
      ++ capabilities. 


  Implementation ==  add 
    
    Rep := Record(d:DOM,f:MAP)


    (x:% = y:%):Boolean == 
      l:NNI:=min(#(x.d),#(y.d))
      v:List X
      for j in 1..l repeat
        s:X:=subscript('z,[j::OF])::X
        v:=concat(v,s::X)
      x.d =y.d and (x.f) v = (y.f) v => true
      false


    cellMap(d:DOM,f:MAP):% == 
      #d > n => error concat("#DOM > ",string n)
      v:List X:=[1::X for j in 1..#d]
      ~test(#f(v)=n) => error concat("#Range ~= ", string n) 
      construct(d,f)


    faceLoHi(x:%,i:NNI,lo:Boolean):% ==
      l:NNI:=#(x.d)
      v:List X
      for j in 1..l repeat
        if j=i then
          if lo then
            s:X:=lo(x.d.i)
          else
            s:X:=hi(x.d.i)
        else
          if j>i then
            s:X:=subscript('%,[(j-1)::OF])::X
          else
            s:X:=subscript('%,[j::OF])::X
        v:=concat(v,s::X)
      vv:=delete(v,i..i)
      d:List(Segment X):=delete(x.d,i..i)
      f:MAP:=vv+->(x.f) v
      cellMap(d,f)
      
     
    faces(x:%):List List(%) ==
      l:NNI:=#(x.d)
      [[faceLoHi(x,j,true), faceLoHi(x,j,false)] for j in 1..l]
        
        
    getDom(x) == x.d
    getMap(x) == x.f
    
    
    coerce(x) == 
      v:List X
      for j in 1..#(x.d) repeat
        s:X:=subscript('%,[j::OF])::X
        v:=concat(v,s::X)
      r:List X:=(x.f) v
      hconcat ["|",x.d::OF," -> ",r::OF,"|"]
  
    
      
)abbrev domain SCMPLX SurfaceComplex
++
SurfaceComplex(R,n) : Exports == Implementation where

  NNI ==> NonNegativeInteger
  INT ==> Integer
  
  n : NNI
  R : Join(Ring,Comparable)
  
  CMAP ==> CellMap(R,n)
  CTOF ==> CoercibleTo OutputForm
  X    ==> Expression R
  OF   ==> OutputForm
  MAP  ==> List X -> List X
  DOM  ==> List(Segment X)

  Exports == Join(AbelianGroup ,CTOF, RetractableTo CMAP) with
 
    bdry : % -> %
      ++ bdry(S) computes the boundary of the surface complex S.
    size : % -> NNI
      ++ size(S) returns the number of "pieces" of the surface complex S.
    nthCoef : (%,Integer) -> Integer
      ++ nthCoef(x, n) returns the coefficient of the n^th term of x.
    nthFactor : (%,Integer) -> CMAP
      ++ nthFactor(x, n) returns the factor of the n^th term of x.
    zero? : % -> Boolean 
      ++ zero?(S) returns true if S is the empty surface complex.
    _= : (%,%) -> Boolean
      ++ S=S' checks if the surface complexes S and S' are equal.
    terms : % -> List(Record(gen: CMAP,exp: Integer))
      ++ terms(S) returns all terms of S as a record.
    mapGen : ((CMAP -> CMAP),%) -> %
      ++ mapGen(f, e1 a1 +...+ en an) returns
      ++ \spad{e1 f(a1) +...+ en f(an)}.
    mapCoef : ((Integer -> Integer),%) -> %
      ++ mapCoef(f, e1 a1 +...+ en an) returns
      ++ \spad{f(e1) a1 +...+ f(en) an}.
    construct : (DOM,MAP) -> %
      ++ construct(d,f) constructs a term (piece) of a k-surface, where
      ++ d is the domain (a k-cell) and f is a mapping from d to a vector
      ++ space of dimension n.
    
    
    --coerce : % -> OutputForm
    
  Implementation == FreeAbelianGroup(CMAP) add

    Rep:=FreeAbelianGroup(CMAP)
      

    bdry(c:%):% == 
      if size(c) = 1 then
        s:=nthFactor(c,1)
        l:=faces(s)
        fs:=[(a.2::Rep-a.1::Rep) for a in l]
        sgn:=(j:INT):INT+->if even? (j-1) then 1 else -1
        nthCoef(c,1)*reduce("+",[sgn(j)*fs.j::Rep for j in 1..#fs])
      else
        ct:=[(nthCoef(c,j)*nthFactor(c,j))::Rep for j in 1..size(c)]
        reduce("+",map(bdry,ct))
        
 
    construct(d:DOM,f:MAP):% == cellMap(d,f)$CMAP::%





     
