\iffalse
)lisp (setq |$inclAssertions| nil)
)abbrev package DG1 DifferentialGeometry1
++ Author: Kurt Pagani
++ Date Created: Sun Jan 01 23:25:52 CET 2017
++ License: FriCAS/BSD
++ Required: FriCAS 1.3+ or DeRhamComplex patch.
++   DeRhamComplex, DifferentialForms, SurfaceComplex
++   CellMap
++ References: 
++ Description: This package combines DeRhamComplex, DifferentialForms, 
++   CellMap and SurfaceComplex in order to compute integrals of 
++   differential forms over affince chains (aka p-surfaces), pull backs
++   of forms by cell maps and associated differential geometric quantities.
++   The first list of symbols denotes the independent variables whereas the
++   the second list denotes the dependent variables, i.e. U=f(X). It is
++   similar to zero sections in JetBundle (locally a function graph).
++ Documentation: 
++   pdflatex dg1.spad  (this file, 2x) => pdf file.
++
DifferentialGeometry1(xs,us) : Exports == Implementation where

  R   ==> Expression Integer
  LS  ==> List Symbol
  LB  ==> List Boolean
  PI  ==> PositiveInteger 
  NNI ==> NonNegativeInteger
  INT ==> Integer

  xs: LS
  us: LS
  
  DRCX ==> DeRhamComplex(Integer,xs)
  DRCU ==> DeRhamComplex(Integer,us)
  
  DFX  ==> DifferentialForms(Integer,xs)
  DFU  ==> DifferentialForms(Integer,us)
  
  OCR ==> OrderedCompletion R
  SBR ==> SegmentBinding R
  SBZ ==> SegmentBinding OCR

  EFDI  ==> ElementaryFunctionDefiniteIntegration(INT,R)
  UOCR  ==> Union(f1:OCR,f2: List OCR, fail: "failed", pole: "potentialPole")
 
  Exports ==  with
    
    indVars : () -> List R
      ++ indVars() returns the list of independent variables (x).
      
    depVars : () -> List R
      ++ depVars() returns the list of independent variables (u).
      
    indSymbols : () -> LS
      ++ indSymbols() returns the list of independent symbols (xs).
      
    depSymbols : () -> LS
      ++ depSymbols() returns the list of dependent symbols (us).

    indForms : () -> List DRCX
      ++ indForms() returns the list of independent forms (dx).
      
    depForms : () -> List DRCU
      ++ depForms() returns the list of dependent forms (du).
    
    getTypes : () -> List Type
      ++ getTypes() returns a list of all form and surface types involved 
      ++ in the package. This might be useful/convenient to define 
      ++ corresponding macros.
      
    getDRCX : () -> Type
      ++ getDRCX() returns the asscoiated DeRhamComplex in the independent
      ++ variables indVars(), i.e DeRhamComplex(Integer,xs).
      
    getDRCU : () -> Type
      ++ getDRCU() returns the asscoiated DeRhamComplex in the dependent
      ++ variables depVars(), i.e DeRhamComplex(Integer,us).   
      
    getDFX  : () -> Type    
      ++ getDFX() returns the asscoiated DifferentialForms package in the 
      ++ independent variables indVars(), i.e DifferentialForms(Integer,xs).
      
    getDFU  : () -> Type
      ++ getDFU() returns the asscoiated DifferentialForms package in the 
      ++ dependent variables depVars(), i.e DifferentialForms(Integer,us).
    
    pullBack : (CellMap(Integer,#us),DRCU) -> DRCX
      ++ pullBack(S,w) computes the pull back of the differential
      ++ form w by the cell map S.
      
    pullBack : (SurfaceComplex(Integer,#us),DRCU) -> DRCX
      ++ pullBack(S,w) computes the pull back of the differential
      ++ form w by all cellMaps in a surface complex.

    pullBack : (List Equation R,DRCU) -> DRCX
      ++ pullBack(S,w) computes the pull back of the differential
      ++ form w by the section given as a list of equations of 
      ++ the form U=f(X).

    integrate : (DRCU, CellMap(Integer,#us)) -> R
	  ++ integrate(w,S) computes the integral of a differential form
	  ++ w over a cell map S.
	  
    integrate : (DRCU, SurfaceComplex(Integer,#us)) -> R
	  ++ integrate(w,S) computes the integral of a differential form
	  ++ w over a surface complex SC.
	  
    multipleIntegral : (R,List Symbol,List Segment R) -> R
	  ++ multipleIntegral(f,[x1...],[0..1,...]) computes the integral
	  ++ of the function f over a hypercube.
	  
	
  Implementation ==  add         
        
    indVars() == [coerce(s)$R for s in xs]
    depVars() == [coerce(s)$R for s in us]
    
    indSymbols() == xs
    depSymbols() == us

    indForms() == baseForms()$DFX
    depForms() == baseForms()$DFU
    
    getTypes() == [DRCX,DRCU,DFX,DFU]
    getDRCX()  == DRCX
    getDRCU()  == DRCU
    getDFX()   == DFX
    getDFU()   == DFU

    pullBack(S:CellMap(Integer,#us),w:DRCU):DRCX ==
      k:=#getDom(S)
      k ~= #xs => error "Domain does not match."
      Y:= S indVars() 
      U:= depVars()
      DY:List DRCX:= [d(s*1$DRCX)$DFX for s in Y] -- new forms
      bf:=baseForms()$DFU
      nf:=0$DRCX
      while w ~= 0$DRCU repeat
        lf:=leadingBasisTerm(w)
        lc:=leadingCoefficient(w)
        abt:=atomizeBasisTerm(lf)$DFU
        if abt ~= [] then
          pos:=[position(x,bf) for x in abt]
          yl:List DRCX:=[DY.j for j in pos]
          nbt:DRCX:=reduce("*",yl)
        else
          nbt:DRCX:=1$DRCX
        nc:R:=subst(lc,[U.j = Y.j for j in 1..#U])
        nf:=nf+nc*nbt
        w:=reductum(w)
      nf
         
    pullBack(eqs:List Equation R, w:DRCU):DRCX ==
      #eqs ~= #us => error "#Equations must match #u"
      lh:List R:= [lhs eq for eq in eqs]
      rh:List R:= [rhs eq for eq in eqs]
      X:List R:=indVars()
      U:List R:=depVars()
      chk1:LB:=concat([[freeOf?(s,U.j)$R for s in rh] for j in 1..#U])
      not reduce(_and,chk1) => error "Found dependent vars on rhs."
      sU:Set(R):=set(U)
      slh:Set(R):=set(lh)
      not subset?(sU,slh) => error "Incomplete dependencies."
      Y:List R:=rh
      DY:List DRCX:= [d(s*1$DRCX)$DFX for s in Y] -- new forms
      bf:=baseForms()$DFU
      nf:=0$DRCX
      while w ~= 0$DRCU repeat
        lf:=leadingBasisTerm(w)
        lc:=leadingCoefficient(w)
        abt:=atomizeBasisTerm(lf)$DFU
        if abt ~= [] then
          pos:=[position(x,bf) for x in abt]
          yl:List DRCX:=[DY.j for j in pos]
          nbt:DRCX:=reduce("*",yl)
        else
          nbt:DRCX:=1$DRCX
        nc:R:=subst(lc,[U.j = Y.j for j in 1..#U])
        nf:=nf+nc*nbt
        w:=reductum(w)
      nf


    pullBack(S:SurfaceComplex(Integer,#us),w:DRCU):DRCX ==
      n:=#us
      RC:=Record(gen: CellMap(Integer,n),exp: Integer)
      t:List(RC):=terms(S)$SurfaceComplex(Integer,n)
      r:DRCX:=0$DRCX
      for s in t repeat
        r:=r + s.exp * pullBack(s.gen,w)
      r
        

    multipleIntegral(c:R,d:List Symbol,b:List Segment R):R ==
      #d ~= #b => error "number of vars and bindings must match."
      I:R:=0$R
      f:R:=c
      for j in 1..#d repeat
        J:UOCR:=integrate(f,equation(d.j,(lo(b.j)::OCR .. hi(b.j)::OCR)))$EFDI
        if J case f1 then 
          f:=retract(J.f1)$OCR
        else
          error "cannot integrate :("
      f 

    --todo: nomenclature is F_g(x) -> F(g,x), Int_A f -> int(f,A)
    -- error list
    integrate(w:DRCU, S:CellMap(Integer,#us)):R ==
      p:PI:=#(getDom S)::PI 
      w:=proj(p,w)$DFU
      w = 0$DRCU => 0$R
      a:DRCX:=pullBack(S,w)
      a = 0$DRCX => 0$R
      k:PI:=degree(a)$DRCX::PI
      k~=p and not homogeneous?(a)$DRCX => error "Something wrong :("
      c:R:=leadingCoefficient(a)$DRCX
      multipleIntegral(c,xs,getDom S)
      --0$R -- dummy  
     

    integrate(w:DRCU, S:SurfaceComplex(Integer,#us)):R ==
      n:=#us
      RC:=Record(gen: CellMap(Integer,n),exp: Integer)
      t:List(RC):=terms(S)$SurfaceComplex(Integer,n)
      r:R:=0$R
      for s in t repeat
        r:=r + s.exp * integrate(w,s.gen)
      r


)if false
\fi
TeX ...
)endif