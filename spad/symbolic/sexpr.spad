-- Type safe representation
rep(x) ==> x @ % pretend Rep
per(x) ==> x @ Rep pretend %
-- Applicative-style macros
Maybe(S) ==> Union(S,"failed")
applyIf(f,x) ==> if (%r:=x) case "failed" then "failed" else f(%r)
returnIf(x) ==> if not((%r:=x) case "failed") then return %r
orReturn(x) ==> if x case "failed" then return "failed"

SIN ==> InputForm
Pair SIN ==> Record(left:SIN,right:SIN)

)abbrev package SINF SINFunctions
-- This should be built-in to InputForm, i.e. InputForm should satisfy Comparable
SINFunctions(): with
    smaller? : (SIN,SIN) -> Boolean
    rank: (Symbol,Integer) -> Symbol
    rank: Symbol -> Integer
  == add
    rank(x:Symbol,n:Integer):Symbol ==
      PUT(x,'rank,convert(n)@SIN)$Lisp
      x
    rank(x:Symbol):Integer ==
      r:SIN := GET(x,'rank)$Lisp
      integer? r => integer r
      0
    --null < integer < float < symbol rank < symbol rank < list
    --null < symbol rank < symbol rank < float < integer < list
    smaller1?(x:SIN,y:SIN):Boolean ==
      --if _$testingSystem$Lisp then
      --  output("smaller1? ",bracket [x::OutputForm,y::OutputForm])$OutputPackage
      null? y => return false
      symbol? y => null? x
        or symbol? x and (rank symbol x < rank symbol y
          or rank symbol y = rank symbol x and -- symbol x < symbol y)
          (symbol x = '_^ => '_*; symbol x = '_* => '_^; symbol x) < (symbol y = '_^ => '_*; symbol y = '_* => '_^; symbol y) )
      integer? y => null? x or symbol? x
        or integer? x and integer x < integer y
      float? y => null? x or integer? x or symbol? x
        or float? x and float x < float y
      -- reverse lexical ordering??
      if list? y then
        if null? x or integer? x or float? x or symbol? x then return true
        if list? x then
          -- arguments
          x1:=cdr x; y1:=cdr y
          while not null? car x1 repeat
            if null? car y1 then return true
            if smaller?(car x1, car y1) then return true
            if smaller?(car y1, car x1) then return false
            x1:=cdr x1; y1:=cdr y1
          -- operators
          return smaller?(car x,car y)
--          (# cdr x < # cdr y or (
--             # cdr x = # cdr y and # cdr x > 0 and (smaller?(cdr x,cdr y) or
--               not smaller?(cdr y, cdr x) and smaller?(car x,car y))))

--          smaller?(car x,car y) or
--            not smaller?(car y,car x) and # cdr x > 0 and smaller?(cdr x,cdr y)

--          (# cdr x < # cdr y or (
--             # cdr x = # cdr y and
--              (smaller?(car x,car y) or
--                not smaller?(car y,car x) and # cdr x > 0 and smaller?(cdr x,cdr y))))

--            (smaller?(cdr x,cdr y) or
--              not smaller?(cdr y, cdr x) and smaller?(car x,car y))))

--          (smaller?(car x,car y) or
--            not smaller?(car x, car y) and smaller?(cdr x, cdr y))

--          (smaller?(cdr x,cdr y) or
--             not smaller?(cdr y, cdr x) and smaller?(car x,car y))
      false
    smaller?(x:SIN,y:SIN):Boolean ==
      -- It is not yet proven that smaller? is a total order.
      -- smaller? == smaller1? except it checks for total order.
      -- To be removed in the future.
      if _$testingSystem$Lisp and smaller1?(x,y) and smaller1?(y,x) then
        output("smaller? ",bracket [x::OutputForm,y::OutputForm])$OutputPackage
        error("smaller? total order failed")
      else
        return smaller1?(x,y)

)abbrev category SYMCAT SymbolicCategory
SymbolicCategory(R : Comparable) : Category == Exports where
  --F ==> Expression R
  Exports ==> Join(FunctionSpace R, CoercibleTo OutputForm, ConvertibleTo SIN) with
    axioms: () -> List Equation SIN
    -- Do we want these even if R not a Ring, e.g. Symbol ?
    _+: (%,%) -> %
    _-: (%,%) -> %
    _-: % -> %
    _*: (%,%) -> %
    _*:(PositiveInteger,%) -> %
    _*:(NonNegativeInteger,%) -> %
    _/: (%,%) -> %
    _^: (%,%) -> %
    _^: (%,Integer) -> %
    nthRoot: (%, %) -> %
    nthRoot: (%, Integer) -> %
    if R has IntegralDomain then
      Ring
      AlgebraicallyClosedFunctionSpace R
      TranscendentalFunctionCategory
      CombinatorialOpsCategory
      LiouvillianFunctionCategory
      SpecialFunctionCategory
      coerce: Polynomial R -> %
      -- transformations
      expand: % -> %
    if % has FunctionSpace(Integer) then
      factor: % -> %
    if % has TranscendentalFunctionCategory and R has GcdDomain then
      simplify : % -> %
    -- coercions
    coerce: Pi -> %
    coerce: % -> Expression(R)
    coerce: Expression(R) -> %
    convert: Equation % -> Equation SIN
    convert: Equation SIN -> Equation %
    coerce: SIN -> %
    --
    equal?: Equation % -> Boolean

)abbrev category AXIOM Axiom
++ Properties and axioms for symbolic rewrite rules
Axiom(): Category == Type with
    assert: (String,Boolean)->Void
  add
    -- Assertion (intended to be run at domain instantiation)
    assert(name:String,axiom:Boolean) ==
      if not axiom then error name
      else if _$testingSystem$Lisp then output(name)$OutputPackage

)abbrev category ALTAX AntiCommutativeAxiom
++ AntiCommutative
AntiCommutativeAxiom(): Category == Axiom with
    rewriteAntiCommutative: (SIN->SIN,(SIN,SIN)->SIN, SIN, SIN) -> Maybe(SIN)
  add
    rewriteAntiCommutative(m:SIN->SIN,f:(SIN,SIN)->SIN, x:SIN, y:SIN): Maybe(SIN) ==
      --output("rewriteAntiCommutative: ",paren [x::OutputForm,y::OutputForm])$OutputPackage
      if symbol? x and symbol? y
        and rank(symbol x)$SINFunctions < 0
          and rank(symbol y)$SINFunctions  < 0 then
            -- non-commutative symbols anti-commute
            if smaller?(y,x)$SINFunctions then
              --output("rewriteAntiCommutative: ",m(f(y,x))::OutputForm)$OutputPackage
              return m(f(y,x))
            if not smaller?(x,y) then return 0
      -- everythning else commutes
      if smaller?(y,x)$SINFunctions then return f(y,x)
      "failed"

)abbrev category ASSAX AssociativeAxiom
++ Associative
AssociativeAxiom(): Category == Axiom with
    rewriteAssociative: (SIN->Maybe Pair SIN, (SIN,SIN)->SIN, SIN) -> Maybe SIN
  add
    rewriteAssociative(terms:SIN->Maybe Pair SIN, f:(SIN,SIN)->SIN, sin:SIN):Maybe(SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteAssociative: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      -- to the right
      --if (t:=terms(x)) case Pair SIN then
      --  rin := f(t.left,f(t.right,y))
      -- to the left
      if (t:=terms(y)) case Pair SIN then
        rin := f(f(x,t.left),t.right)
      else
        return "failed"
      if _$testingSystem$Lisp then
        output("rewriteAssociative: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
        if not smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category ASSAX+ AssociativeAxiom+
AssociativeAxiom_+():Category == AssociativeAxiom
)abbrev category ASSAXS AssociativeAxiom*
AssociativeAxiom_*():Category == AssociativeAxiom

)abbrev category CANAX CancelsAxiom
++ Cancelling
CancelsAxiom(): Category == Axiom with
    rewriteCancels: SIN -> Maybe SIN
  add
    rewriteCancels(sin:SIN):Maybe SIN ==
      if _$testingSystem$Lisp then
        output("rewriteCancels: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if integer? x and integer? y then
        rin := convert(integer(x)-integer(y))
      else
        if float? x and float? y then
          rin := convert(float(x)-float(y))
        else
          if x = y then
            rin := 0
          else
            return "failed"
      if _$testingSystem$Lisp then
        output("rewriteCancels: ",infix(message " --> ",coerce(sin)@OutputForm,coerce(rin)@OutputForm))$OutputPackage
        if smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category COMAX CommutativeAxiom
++ Commutative
CommutativeAxiom(): Category == Axiom with
    rewriteCommutative: (SIN->Maybe Pair SIN,(SIN,SIN)->SIN, SIN) -> Maybe(SIN)
  add
    rewriteCommutative(terms:SIN->Maybe Pair SIN,f:(SIN,SIN)->SIN, sin:SIN): Maybe(SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteCommutative: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if smaller?(x,y)$SINFunctions then
        rin := f(y,x)
      else
        -- look on the left
        if % has AssociativeAxiom and (tx := terms x) case Pair SIN then
          if smaller?(tx.right,y) then
            rin := f(tx.left,f(y,tx.right))
        -- look on the right
        --if % has AssociativeAxiom and (ty := terms y) case Pair SIN then
        --  if smaller?(x,ty.left) then
        --    rin := f(f(ty.left,x),ty.right)
          else
            return "failed"
        else
          return "failed"
      if _$testingSystem$Lisp then
        output("rewriteCommutative: ",infix(message " --> ", message unparse sin,message unparse rin))$OutputPackage
        if not smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category COMAX+ CommutativeAxiom+
CommutativeAxiom_+():Category == CommutativeAxiom
)abbrev category COMAX1 CommutativeAxiom*
CommutativeAxiom_*():Category == CommutativeAxiom
)abbrev category COMAX2 CommutativeAxiom**
CommutativeAxiom_*_*():Category == CommutativeAxiom
)abbrev category COMAX3 CommutativeAxiom/\
CommutativeAxiom_/_\():Category == CommutativeAxiom

)abbrev category DBLAX DoublesAxiom
++ Doubling
DoublesAxiom(): Category == Axiom with
    rewriteDoubles: (SIN->Maybe Pair SIN,(SIN,SIN)->SIN,(SIN,SIN)->SIN,SIN) -> Maybe SIN
  add
    rewriteDoubles(terms:SIN->Maybe Pair SIN, plus:(SIN,SIN)->SIN, times:(SIN,SIN)->SIN,sin:SIN):Maybe SIN ==
      if _$testingSystem$Lisp then
        output("rewriteDoubles: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if integer? x and integer? y then
        rin := convert(integer(x)+integer(y))
      else
        if float? x and float? y then
          rin := convert(float(x)+float(y))
        else
          if x = y then
            rin := times(convert(2),x)
          else
            -- look right
            if % has AssociativeAxiom_+ and (tx:=terms(x)) case Pair SIN then
              r2:=rewriteDoubles(terms,plus,times,convert [car sin,tx.right,y])
              if r2 case SIN then
                rin := plus(tx.left,r2)
            -- look left
            --if % has AssociativeAxiom_+ and (ty:=terms(y)) case Pair SIN then
            --  r2:=rewriteDoubles(terms,plus,times,convert [car sin,x,ty.left])
            --  if r2 case SIN then
            --    rin := plus(r2,ty.right)
              else
                return "failed"
            else
              return "failed"
      if _$testingSystem$Lisp then
        output("rewriteDoubles: ",infix(message " --> ", message unparse sin,message unparse rin))$OutputPackage
        if not smaller?(sin,rin)$SINFunctions then error "not smaller"
      return rin

)abbrev category DISAX DistributiveAxiom
++ Distributive
DistributiveAxiom(): Category == Axiom with
    rewriteDistributive: (SIN->Maybe Pair SIN, (SIN,SIN)->SIN, (SIN,SIN)->SIN, SIN) -> Maybe SIN
  add
    rewriteDistributive(terms:SIN->Maybe Pair SIN, plus:(SIN,SIN)->SIN, times:(SIN,SIN)->SIN, sin:SIN): Maybe(SIN) ==
      if _$testingSystem$Lisp then
        output("rewriteDistributive: ",message unparse sin)$OutputPackage
      x:=sin.2; y:=sin.3
      rin:SIN
      if (t:=terms(x)) case Pair SIN then
        rin := plus(times(t.left,y),times(t.right,y))
      else
        if (t:=terms(y)) case Pair SIN then
          rin := plus(times(x,t.left),times(x,t.right))
        else
          return "failed"
      if _$testingSystem$Lisp then
        output("rewriteDistributive: ",infix(message " --> ",message unparse sin,message unparse rin))$OutputPackage
        if not smaller?(sin,rin)$SINFunctions then output("not smaller")$OutputPackage
      return rin

)abbrev category DIVAX DividesAxiom
++ Divides
DividesAxiom(): Category == Axiom with
    rewriteDivides: (SIN, SIN) -> Maybe SIN
  add
    rewriteDivides(x:SIN, y:SIN): Maybe SIN ==
      if eq(y,0) then return "failed"
      if eq(x,0) then return 0
      if integer? x and integer? y then
        orReturn(r:=integer(x) exquo integer(y))
        return convert r
      if float? x and float? y then return convert(float(x)/float(y))
      if x = y then return 1
      "failed"

)abbrev category INVAX InverseAxiom
++ Inverse
InverseAxiom(): Category == Axiom with
    rewriteInverse: (SIN->SIN,SIN,SIN,SIN)-> Maybe SIN
    rewriteInverseUnary: (SIN->SIN,SIN->Maybe Pair SIN,(SIN,SIN)->SIN,SIN) -> Maybe SIN
    rewriteInverseBinary: (SIN->SIN,(SIN,SIN)->SIN,SIN,SIN)-> Maybe SIN
  add
    rewriteInverse(inv:SIN->SIN,u:SIN,x:SIN,y:SIN): Maybe SIN ==
      if inv(x) = y then return u
      if inv(y) = x then return u
      "failed"
    rewriteInverseUnary(inv:SIN->SIN,terms:SIN->Maybe Pair SIN,f:(SIN,SIN)->SIN, x:SIN) ==
      --output("rewriteInverseUnary: ",coerce(x)@OutputForm)$OutputPackage
      if list? x then
        if % has AssociativeAxiom and (t:=terms(car cdr x)) case Pair SIN then
          return f(inv t.left, inv t.right)
      "failed"
    rewriteInverseBinary(inv:SIN->SIN,f:(SIN,SIN)->SIN,x:SIN,y:SIN): Maybe SIN ==
      if list? x and inv(x) = car cdr x then return f(y,inv x)
      if list? y and inv(y) = car cdr y then return f(x,inv y)
      "failed"

)abbrev category LIDAX LeftIdentityAxiom
++ Left Identities
LeftIdentityAxiom(): Category == Axiom with
    rewriteIdentityLeft: (SIN,SIN,SIN)-> Maybe SIN
  add
    rewriteIdentityLeft(u:SIN,x:SIN,y:SIN): Maybe SIN ==
      --output("rewriteIdentityLeft: ",paren [u::OutputForm,x::OutputForm,y::OutputForm])$OutputPackage
      if x=u then y else "failed"

)abbrev category RIDAX RightIdentityAxiom
++ Right Identities
RightIdentityAxiom(): Category == Axiom with
    rewriteIdentityRight: (SIN,SIN,SIN)-> Maybe SIN
  add
    rewriteIdentityRight(u:SIN,x:SIN,y:SIN): Maybe SIN ==
      --output("rewriteIdentityRight: ",paren [u::OutputForm,x::OutputForm,y::OutputForm])$OutputPackage
      if y=u then x else "failed"

)abbrev category IDAX IdentityAxiom
++ Identities
IdentityAxiom(): Category == Join(LeftIdentityAxiom,RightIdentityAxiom)

)abbrev category SQAX SquaresAxiom
++ Squares
SquaresAxiom(): Category == Axiom with
    rewriteSquares: ((SIN,SIN)->SIN, SIN->Maybe Pair SIN, (SIN,SIN)->SIN, SIN->Maybe Pair SIN, SIN, SIN) -> Maybe SIN
  add
    rewriteSquares( pow:(SIN,SIN)->SIN, ispower:SIN->Maybe Pair SIN, times:(SIN,SIN)->SIN, istimes:SIN->Maybe Pair SIN, x:SIN, y:SIN ) : Maybe SIN ==
      --output("rewriteSquares: ",paren [x::OutputForm,y::OutputForm])$OutputPackage
      -- constants
      if integer? x and integer? y then return convert(integer(x)*integer(y))
      if float? x and float? y then return convert(float(x)*float(y))
      -- x*x --> x^2
      if x = y then return pow(x,convert 2)
      -- x*x^n --> x^(n+1)
      if (t:=ispower(y)) case Pair SIN and t.left = x and integer? t.right then
        return pow(t.left,convert(integer(t.right)+1))
      if % has AssociativeAxiom_* then
        -- (x*y)*y --> x*y^2
        if (t:=istimes(x)) case Pair SIN and t.left = y then
          return times(t.left,pow(t.right,convert 2))
      "failed"

)abbrev domain SYMB Symbolic
++ Unevaluated mathematical expressions
++ Author: Bill Page
++ Date Created: 4 December 2016
++ Description:
++ Symbolic is a domain that represents expressions involving symbolic
++ operations. These expressions remain unevaluated and are displayed as
++ entered unless otherwise specified. Rewrite rules implementing various
++ common axioms can be specified that will be automatically applied when
++ expressions are evaluated by the interpreter. Full simplification of
++ expressions if/when desired is performed by means of interpretation in the Expression domain.
++ Keywords: expression, evaluation, operator, function.
Symbolic(R:Comparable, AxiomList:Type):SymbolicCategory(R) == Implementation where
  --F ==> Expression R
  K   ==> Kernel %
  KF  ==> Kernel F
  SMP  ==> SparseMultivariatePolynomial(R, K)
  --AF  ==> AlgebraicFunction(R, F)
  --EF  ==> ElementaryFunction(R, F)
  CF  ==> CombinatorialFunction(R, F)
  --LF  ==> LiouvillianFunction(R, F)
  --AN  ==> AlgebraicNumber
  --KAN ==> Kernel AN
  --ESD ==> ExpressionSpace_&(F)
  --FSD ==> FunctionSpace_&(F, R)

  Implementation ==> add
    Rep := SIN
    --rep(x:%):Rep == x pretend Rep
    --per(x:Rep):% == x pretend %
    smaller?(x:%,y:%):Boolean == smaller?(rep x, rep y)$SINFunctions

    belong? op == true
    if R has AbelianSemiGroup then
      0:% == per 0$Rep
      zero? x == x = 0
    if R has SemiGroup then
      1:% == per 1$Rep
      one? x  == x = 1

    hash(x:%):SingleInteger == hash(rep x)$SIN
    equal?(eq:Equation %):Boolean == not smaller?(lhs eq,rhs eq) and not smaller?(rhs eq,lhs eq)
    (x:% = y:%):Boolean == not smaller?(x,y) and not smaller?(y,x)

    subst(x:%,e:Equation %):% == per SUBST(rep rhs e,rep lhs e,rep x)$Lisp
    subst(x:%,ks:List Kernel %, vs:List %) ==
      if #ks > 1 then return subst(subst(x,equation(first(ks)::%,first(vs))),rest ks, rest vs)
      else return subst(x,equation(first(ks)::%,first(vs)))
    subst(x:%, es:List Equation %):% ==
      if #es > 1 then return subst(subst(x, first es),rest es)
      else subst(x, first es)
    --
    eval(x:%,k:Kernel(%),s:%):% ==
      --output("eval 1:", paren [x::OutputForm, k::OutputForm, s::OutputForm])$OutputPackage
      coerce rep subst(x,[k],[s])
    eval(x:%,ks:List Kernel %, vs:List %) ==
      --output("eval 2:", paren [x::OutputForm, ks::OutputForm, vs::OutputForm])$OutputPackage
      r:=x
      -- Use temporary symbols in case of parallel substitutions
      ts:List Kernel % := [kernel(new()$Symbol) for k in ks]
      for k in ks for t in ts repeat
        r:=eval(r,k,coerce t)
      for t in ts for v in vs repeat
        r:=eval(r,t,v)
      return r
    if R has ConvertibleTo SIN then
      eval(x:%):% ==
        --output("eval 0:", x::OutputForm)$OutputPackage
        interpret(convert(x)@SIN)$InputFormFunctions1(%)
    eval(x:%,a:%,b:%):% ==
      --output("eval 3:", paren [x::OutputForm, a::OutputForm, b::OutputForm])$OutputPackage
      eval(x, retract a, b)
    eval(x:%,e:Equation %):% == eval(x,lhs e,rhs e)
    --
    -- need to handle subscripted Symbol
    retractIfCan(x:%):Maybe(Kernel %) ==
      --output("retractIfCan Kernel: ",x::OutputForm)$OutputPackage
      if atom? rep x and symbol? rep x then return kernel symbol rep x
      if list? rep x and symbol? car rep x then
        if list? cdr rep x then
          s := symbol car rep x
          -- Why not '_- ??
          if not member?(s,['_+,'_*,'_/])$List(Symbol) then
            k:Kernel(%) := kernel(operator(s)$CommonOperators,
              destruct cdr rep x, #cdr(rep x)::NonNegativeInteger)
            return k
          else
            return "failed"
        else
          return "failed"
      else
        return "failed"
    retractIfCan(x:%):Maybe(R) ==
      --output("retractIfCan R: ",x::OutputForm)$OutputPackage
      if list? rep x and # cdr rep x = 0 then error "stop"
      if R is Integer then
        if integer? rep x then return (integer rep x) pretend R
      if R is DoubleFloat then
        if float? rep x then return (float rep x) pretend R
      if R is Symbol then
        if symbol? rep x then return (symbol rep x) pretend R
      --
      return "failed"
    retractIfCan(x:%):Maybe(Symbol) ==
      --output("retractIfCan Symbol: ",x::OutputForm)$OutputPackage
      if symbol? rep x then symbol rep x
      else "failed"
    retract(x:%):Symbol ==
      --output("retract Symbol: ",x::OutputForm)$OutputPackage
      s:=retractIfCan(x)@Maybe(Symbol)
      if s case Symbol then return s
      error "not a Symbol"
    --
    isPlus1(x:SIN):Maybe(Pair SIN) ==
      list? x and symbol? car x and symbol car x = '_+ => [car cdr x, car cdr cdr x]
      "failed"
    isTimes1(x:SIN):Maybe(Pair SIN) ==
      list? x and symbol? car x and symbol car x = '_* => [car cdr x, car cdr cdr x]
      "failed"
    isDivide1(x:SIN):Maybe(Pair SIN) ==
      list? x and symbol? car x and symbol car x = '_/ => [car cdr x, car cdr cdr x]
      "failed"
    if R has IntegralDomain then
      -- Symbolic is syntactical!
      numerator(x:%):% ==
        r := isDivide1 rep x
        if r case Pair SIN then
          return per r.left
        else
          return x
      denominator(x:%):% ==
        r := isDivide1 rep x
        if r case Pair SIN then
          return per r.right
        else
          return 1
      makeKernel(x:%):Kernel % ==
        --output("makeKernel: ",x::OutputForm)$OutputPackage
        if symbol? rep x then return kernel symbol rep x
        k:Maybe(Kernel %):=retractIfCan(x)
        if k case Kernel % then
          return k
        else
          -- We must wrap up this term in a paren box for SMP.
          return coerce kernel(operator('%box)$CommonOperators,[x],1)$K
      smpTerm(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("smpTerm: ",x::OutputForm)$OutputPackage
        t:=isTimes x
        if t case List % then
          return reduce("*",[smpTerm(i) for i in t])
        t2:=isPower x
        if t2 case Record(val:%,exponent:Integer) then
          if t2.exponent > 0 then
            return smpTerm(t2.val)^(t2.exponent::NonNegativeInteger)
        -- this test is not quite adequate
        if R is Integer and integer? rep x then
          return coerce integer rep x
        else
          return coerce makeKernel(x)
      numer(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("numer: ",x::OutputForm)$OutputPackage
        r:=numerator(x)
        s:=isPlus r
        if s case List % then
          return reduce("+",[smpTerm(i) for i in s])
        else
          return smpTerm(r)
      denom(x:%):SparseMultivariatePolynomial(R,Kernel %) ==
        --output("denom: ",x::OutputForm)$OutputPackage
        r:=denominator(x)
        s:=isPlus r
        if s case List % then
          return reduce("+",[smpTerm(i) for i in s])
        else
          return smpTerm(r)

      (x:SMP / y:SMP):% == coerce(x) / coerce(y)
      isPlus(x:%):Maybe(List %) ==
        r := isPlus1 rep x
        if r case Pair SIN then
          r1:=isPlus per(r.left)
          r2:=isPlus per(r.right)
          if r1 case List % then
            if r2 case List % then
              concat(r1,r2)
            else
              concat(r1, [per(r.right)])
          else
            if r2 case List % then
              concat([per(r.left)],r2)
            else
              [per(r.left),per(r.right)]
        else
          "failed"

      --factorials(x:%):%           == coerce factorials(coerce x)$CF
      --factorials(x:%, n:Symbol):% == coerce factorials(coerce x, n)$CF

      if SMP has PolynomialFactorizationExplicit then
        factor(x:%):% ==
          (factor(numer x)::OutputForm pretend SIN /
            factor(denom x)::OutputForm pretend SIN)$SIN

      expand(x:%):% ==
        n := isPlus numerator(x)
        if n case List % then
          d:% := denominator(x)
          if d=1 then return reduce("+",[s for s in n])
          return reduce("+",[s/d for s in n])
        else
          return x
      --
      if R has ConvertibleTo SIN then
        coerce(x:SMP):% == per convert(x)$SMP
        coerce(x:Polynomial R):% == per convert(x)$Polynomial(R)
        coerce(x:Fraction R):% == per convert(x)$Fraction(R)
      if R has RetractableTo Integer or R has RetractableTo Fraction Integer then
        retractIfCan(x:%):Maybe(Fraction Integer) ==
          r:Maybe(R):=retractIfCan(x)
          if R has RetractableTo Fraction Integer then
            return retractIfCan(r::R)@Maybe(Fraction Integer)
          if R has RetractableTo Integer then
            r2:Maybe(Integer):=retractIfCan(r::R)
            if r2 case Integer then return r2::Integer::Fraction Integer
          return "failed"
      if R has PatternMatchable Integer then
        patternMatch(x : %, p : Pattern Integer, l : PatternMatchResult(Integer, %)) ==
          --output("patternMatch: ",paren [x::OutputForm,p::OutputForm,l::OutputForm])$OutputPackage
          patternMatch(x, p, l)$PatternMatchFunctionSpace(Integer, R, %)

      if R has PatternMatchable Float then
        patternMatch(x : %, p : Pattern Float, l : PatternMatchResult(Float, %)) ==
          patternMatch(x, p, l)$PatternMatchFunctionSpace(Float, R, %)

    if R has SemiGroup then
      isTimes(x:%):Maybe(List %) ==
        r := isTimes1 rep x
        if r case Pair SIN then
          r1:=isTimes per(r.left)
          r2:=isTimes per(r.right)
          if r1 case List % then
            if r2 case List % then
              concat(r1,r2)
            else
              concat(r1, per(r.right))
          else
            if r2 case List % then
              concat(per(r.left),r2)
            else
              [per(r.left),per(r.right)]
        else
          "failed"

    coerce(x:Pi):% == per convert(x)$Pi
    coerce(x:Symbol):% == per convert(x)$Symbol
    --coerce(k:Kernel %):% == coerce name(k)
    coerce(k:Kernel %):% == per convert(k)@Rep

    coerceOutputForm1:(Rep,Boolean)->OutputForm
    coerceOutputForm(x:Rep):OutputForm ==coerceOutputForm1(x,false)
    coerceOutputForm1(x:Rep,topLevel:Boolean):OutputForm ==
      if null? x then return empty()$OutputForm
      if atom? x then return (x pretend OutputForm)
      if list? x and symbol? car x then
        s := symbol car x
        -- scripted?
        if #string(s)>2 and ord string(s).1 = 42 and digit? string(s).2 then
          return coerce(x pretend Symbol)
        if s='%paren then
          return paren coerceOutputForm car cdr x
        if s='%box then
          -- make box invisible (for now)
          return coerceOutputForm car cdr x
          return bracket coerceOutputForm car cdr x
        if s='float then
          return interpret(x)$InputFormFunctions1(Float)::OutputForm
        if s='factorial then
          if list? car(cdr x) then
            return postfix(outputForm '_!, paren coerceOutputForm car cdr x)
          else
            return postfix(outputForm '_!, coerceOutputForm car cdr x)
        if s='sum or s='summation then
            return sum(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='product then
            return prod(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='binomial then
            return binomial(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='sqrt then
            return root coerceOutputForm car cdr x
        if s='nthRoot then
            return root(coerceOutputForm car cdr x, coerceOutputForm car cdr cdr x)
        if s='_^ and car cdr cdr x = convert(1/2) then
            return root(coerceOutputForm car cdr x)
        if s='exp and car(cdr x)=1 then return outputForm '%e
        if member?(s,['_+,'_-,'_*,'_/,'_^])$List(Symbol) and #cdr(x)>1 then
          if s='_/ then -- assume )set output fraction vertical (should check flag?)
            return infix(outputForm s, [coerceOutputForm1(i,true) for i in destruct cdr x])
          else if AxiomList has AssociativeAxiom or topLevel then
            return infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
          else -- ( ) required if non-associative
            return paren infix(outputForm s, [coerceOutputForm(i) for i in destruct cdr x])
        else
          if list? car(cdr x) or s ~= '_- then
            return prefix(outputForm s,
              [coerceOutputForm(i) for i in destruct cdr x])
          else
            return hconcat([outputForm s, hspace(1), coerceOutputForm car cdr x])
      else
        return hconcat(message("what is:")$OutputForm,x pretend OutputForm)
    coerce(x:%):OutputForm == coerceOutputForm1(rep x,true)

    -- +0 is a hack to avoid premature conversion (do we need it?)
    hack(x:%):Rep == binary(convert('_+),[rep x,0$Rep])

    coerce(x:%):Expression(R) ==
      --output("coerce: Expression(R)",x::OutputForm)$OutputPackage
      v:List Symbol := variables x
      if #v = 0 then return interpret(hack x)$InputFormFunctions1(Expression(R))
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation % := [equation(coerce(vi)$%, coerce(si)$%) for vi in v for si in s]
      sk:List Equation Expression(R) := [equation(coerce(si)$Expression(R), coerce(vi)$Expression(R)) for vi in v for si in s]
      return subst(interpret(hack subst(x,ks))$InputFormFunctions1(Expression(R)),sk)
    if R has ConvertibleTo SIN then
      coerce(x:Expression(R)):% == per convert(x)$Expression(R)
      coerce(x:R):% == per convert(x)$R
    convert(x:%):SIN == rep x
    coerce(x:SIN):% == per x
    --
    factorial(x:%):%          == per convert([convert('factorial)@SIN,rep x])
    binomial(n:%, m:%):%      == binary(convert('binomial),[n::Rep,m::Rep])$SIN
    permutation(n:%, m:%):%   == binary(convert('permutation),[n::Rep,m::Rep])$SIN
    --
    sum(x : %, n : Symbol):%           == per binary(convert('sum),[rep x,convert(n)@SIN])$SIN
    sum(x : %, s : SegmentBinding %):% == per binary(convert('sum),[rep x,convert(s)@SIN])$SIN
    summation(x : %, n : Symbol):%           == per binary(convert('summation),[rep x,convert(n)@SIN])$SIN
    summation(x : %, s : SegmentBinding %):% == per binary(convert('summation),[rep x,convert(s)@SIN])$SIN
    product(x : %, n : Symbol):%             == per binary(convert('product),[rep x,convert(n)@SIN])$SIN
    product(x : %, s : SegmentBinding %):%   == per binary(convert('product),[rep x,convert(s)@SIN])$SIN

    -- We don't want the InputForm auto-simplifications because we may or
    -- may not be doing our own simplifications.
    power: (Rep,Rep) -> Rep
    power(x:Rep,y:Rep):Rep == binary(convert('_^),[x,y])$SIN
    (x:% ^ y:%):% == per power(rep x,rep y)
    (x:% ^ y:PositiveInteger):% == expt(x, y)$RepeatedSquaring(%)
    (x:% ^ y:NonNegativeInteger):% ==
      if y = 0 then x^0
      else x ^ y::PositiveInteger
    (x:% ^ y:Integer):% ==
      if y < 0 then 1/(x ^ (-y)::PositiveInteger)
      else x ^ y::NonNegativeInteger
    (x:% ^ y:Fraction Integer):% == nthRoot(x,denom(y))^numer(y)
    isPower1(x:SIN):Maybe(Pair SIN) ==
      list? x and symbol? car x and symbol car x = '_^ => [car cdr x, car cdr cdr x]
      "failed"
    isPower(x:%):Maybe(Record(val:%,exponent:Integer)) ==
      r:=isPower1(rep x)
      if r case Pair SIN then
        if integer?(r.right) then
          return [per r.left,integer(r.right)]
      "failed"
    --
    plus: (Rep,Rep) -> Rep
    minus: (Rep,Rep) -> Rep
    minus1: Rep -> Rep
    div1 : Rep -> Rep

    times(x:Rep,y:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("times: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      sin:SIN:=binary(convert('_*),[x,y])$SIN
      if AxiomList has DistributiveAxiom then
        returnIf rewriteDistributive(isPlus1,plus,times,sin)
      if AxiomList has AssociativeAxiom_* then
        returnIf rewriteAssociative(isTimes1,times,sin)
      if AxiomList has LeftIdentityAxiom then
        returnIf rewriteIdentityLeft(1,x,y)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteIdentityRight(1,x,y)
      if AxiomList has AntiCommutativeAxiom then
        returnIf rewriteAntiCommutative(minus1,times,x,y)
      if AxiomList has CommutativeAxiom_* then
        returnIf rewriteCommutative(isTimes1,times,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteInverse(div1,1,x,y)
        --returnIf rewriteInverseBinary(div1,times,x,y)
      if AxiomList has SquaresAxiom then
        returnIf rewriteSquares(power,isPower1,times,isTimes1,x,y)
      sin
    (x:% * y:%):% == per times(rep x,rep y)
    --
    (x:PositiveInteger * y:%):% == double(x,y)$RepeatedDoubling(%)
    (x:NonNegativeInteger * y:%):% ==
      if x=0 then 0*y
      else x::PositiveInteger * y
    (x:Integer * y:%):% ==
      if x < 0 then
        (-x)::PositiveInteger * y
      else
        x::NonNegativeInteger * y
    --
    plus(x:Rep,y:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("plus: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      sin:SIN:=binary(convert('_+),[x,y])$SIN
      if AxiomList has AssociativeAxiom_+ then
        returnIf rewriteAssociative(isPlus1,plus,sin)
      if AxiomList has LeftIdentityAxiom then
        returnIf rewriteIdentityLeft(0,x,y)
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteIdentityRight(0,x,y)
      if AxiomList has CommutativeAxiom_+ then
        returnIf rewriteCommutative(isPlus1,plus,sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteInverse(minus1,0,x,y)
        returnIf rewriteInverseBinary(minus1,minus,x,y)
      if AxiomList has DoublesAxiom then
        returnIf rewriteDoubles(isPlus1,plus,times,sin)
      sin
    (x:% + y:%):% == per plus(rep x,rep y)

    minus(x:Rep,y:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("minus: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      sin:SIN := binary(convert('_-),[x,y])$SIN
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteIdentityRight(0,x,y)
      if AxiomList has CancelsAxiom then
        returnIf rewriteCancels(sin)
      if AxiomList has InverseAxiom then
        returnIf rewriteInverseBinary(minus1,plus,x,y)
      return sin
    (x:% - y:%):% == per minus(rep x,rep y)

    minus1(x:Rep):Rep ==
      if AxiomList has InverseAxiom then
        -- involution?
        if list? x and # cdr x = 1 and symbol? car x and symbol car x = '_- then
          return car cdr x
        returnIf rewriteInverseUnary(minus1,isPlus1,plus,x)
      convert([convert('_-)@SIN,x])
    _-(x:%):% == per minus1 rep x

    div(x:Rep,y:Rep):Rep ==
      if _$testingSystem$Lisp then
        output("divide: ",paren [coerce(x)@OutputForm,coerce(y)@OutputForm])$OutputPackage
      if AxiomList has RightIdentityAxiom then
        returnIf rewriteIdentityRight(1,x,y)
      if AxiomList has DividesAxiom then
        returnIf rewriteDivides(x,y)
      binary(convert('_/),[x,y])$SIN
    (x:% / y:%):% == per div(rep x,rep y)

    div1(x:Rep):Rep ==
      if AxiomList has InverseAxiom then
        -- involution?
        if list? x and # cdr x = 2 and symbol? car x and symbol car x = '_/ and car cdr x = 1 then
          return car cdr cdr x
        returnIf rewriteInverseUnary(div1,isTimes1,times,x)
      1$Rep/x
    inv(x:%):% ==
      if _$testingSystem$Lisp then
        output("inv: ",x::OutputForm)$OutputPackage
      per div1 rep x

    elt(f:BasicOperator,x:List %):% ==
      --output("elt: ", paren [f::OutputForm,x::OutputForm])$OutputPackage
      if not property(f,'%symbol) case "failed" then
        return per convert name f
      else
        -- Should we actually evaluate the operator??
        return per convert(concat(convert(name f)@SIN,[rep i for i in x]))

    -- Elementary Functions
    acos(x:%):% == per convert([convert('acos)@SIN,rep x])
    acosh(x:%):% == per convert([convert('acosh)@SIN,rep x])
    acot(x:%):% == per convert([convert('acot)@SIN,rep x])
    acoth(x:%):% == per convert([convert('acoth)@SIN,rep x])
    acsc(x:%):% == per convert([convert('acsc)@SIN,rep x])
    acsch(x:%):% == per convert([convert('acsch)@SIN,rep x])
    asec(x:%):% == per convert([convert('asec)@SIN,rep x])
    asech(x:%):% == per convert([convert('asech)@SIN,rep x])
    asin(x:%):% == per convert([convert('asin)@SIN,rep x])
    asinh(x:%):% == per convert([convert('asinh)@SIN,rep x])
    atan(x:%):% == per convert([convert('atan)@SIN,rep x])
    atanh(x:%):% == per convert([convert('atanh)@SIN,rep x])
    cos(x:%):% == per convert([convert('cos)@SIN,rep x])
    cosh(x:%):% == per convert([convert('cosh)@SIN,rep x])
    cot(x:%):% == per convert([convert('cot)@SIN,rep x])
    coth(x:%):% == per convert([convert('coth)@SIN,rep x])
    csc(x:%):% == per convert([convert('csc)@SIN,rep x])
    csch(x:%):% == per convert([convert('csch)@SIN,rep x])
    exp(x:%):% == per convert([convert('exp)@SIN,rep x])
    log(x:%):% == per convert([convert('log)@SIN,rep x])
    nthRoot(x:%, n:Integer) == binary(convert('nthRoot),[rep x,n::Rep])$SIN
    nthRoot(x:%, n:%) == binary(convert('nthRoot),[rep x,n::Rep])$SIN
    --pi():% == per convert([convert('pi)@SIN])
    sec(x:%):% == per convert([convert('sec)@SIN,rep x])
    sech(x:%):% == per convert([convert('sech)@SIN,rep x])
    sin(x:%):% == per convert([convert('sin)@SIN,rep x])
    sinh(x:%):% == per convert([convert('sinh)@SIN,rep x])
    sqrt(x:%):% == per convert([convert('sqrt)@SIN,rep x])
    tan(x:%):% == per convert([convert('tan)@SIN,rep x])
    tanh(x:%):% == per convert([convert('tanh)@SIN,rep x])
    --
    retract(x:%):R == retract(coerce x)$Expression(R)

    variables1(x:Rep):Set Symbol ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [symbol x]
      if list? x and symbol? car x then
        if list? cdr x then
          return reduce("union", [variables1(i) for i in destruct cdr x],empty())
        else
          return variables1 car cdr x
      return empty()
    variables(x:%):List Symbol == members variables1(rep x)

    -- still need to handle non symbols and scripted symbols
    kernels1(x:Rep):Set Kernel % ==
      if null? x then return empty()
      if atom? x and symbol? x then return set [kernel symbol x]
      if list? x and symbol? car x then
          if list? cdr x then
            s := symbol car x
            if member?(s,['_+,'_-,'_*,'_/])$List(Symbol) then
              r:Set Kernel % := reduce("union",
                [kernels1(i) for i in destruct cdr x])
              return r
            else
              k:Kernel(%) := kernel(operator(s)$CommonOperators,
                destruct cdr x, #cdr(x)::NonNegativeInteger)
              return set [k]
          else
            return kernels1 car cdr x
      return empty()
    kernels(x:%):List Kernel % == members kernels1(rep x)

    if Expression(R) has TranscendentalFunctionCategory and R has GcdDomain then
      simplify(x:%):% ==
        coerce(simplify(coerce x)$TranscendentalManipulations(R,Expression R))
    convert(eq:Equation %): Equation SIN == equation(convert lhs eq, convert rhs eq)
    convert(eq:Equation SIN): Equation % == equation(convert lhs eq, convert rhs eq)

)abbrev domain ALT AntiCommutative
AntiCommutative():AntiCommutativeAxiom == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("anticommutative *",y*x = -(x*y))

)abbrev domain ASS+ Associative+
Associative_+():AssociativeAxiom_+ == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("associative +", x+(y+z) = (x+y)+z )

)abbrev domain ASSS Associative*
Associative_*():AssociativeAxiom_* == add
  x:Symbolic(Integer,%):=coerce 'x
  y:Symbolic(Integer,%):=coerce 'y
  z:Symbolic(Integer,%):=coerce 'z
  assert("associative *",x*(y*z)=(x*y)*z)

)abbrev domain CAN Cancels
Cancels():CancelsAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("cancels -",x-x = 0)

)abbrev domain COM+ Commutative+
Commutative_+():CommutativeAxiom_+ == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  assert("commutative +",x+y = y+x)

)abbrev domain COMS Commutative*
Commutative_*():CommutativeAxiom_* == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  assert("commutative *",x*y = y*x)

)abbrev domain DBL Doubles
Doubles():DoublesAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("doubles +",x+x = 2*x )

)abbrev domain DIS Distributive
Distributive():DistributiveAxiom == add
    x:Symbolic(Integer,%) := coerce 'x
    y:Symbolic(Integer,%) := coerce 'y
    z:Symbolic(Integer,%) := coerce 'z
    assert("distributive", x*(y+z)=(x*y)+(x*z) )

)abbrev domain DIV Divides
Divides():DividesAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("divides",x/x = 1)

-- Inverse /\ Cancels --> Identity
-- So who needs inverse?
)abbrev domain LID LeftIdentity
LeftIdentity():LeftIdentityAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("left identity +", 0+x = x )
  assert("left identity *", 1*x = x )

)abbrev domain RID RightIdentity
RightIdentity():RightIdentityAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("right identity +", x+0 = x )
  assert("right identity *", x*1 = x )
  assert("right identity -", x-0 = x )
  assert("right identity /", x/1 = x )

)abbrev domain INV Inverse
Inverse():InverseAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  y:Symbolic(Integer,%) := coerce 'y
  --assert("inverse inverse -",-(-x) = x)
  --assert("inverse inverse /",1/(1/x) = x)
  -- left
  --assert("left inverse +", (-x) + y = -(x - y) )
  --assert("left inverse -", (-x) - y = -(x + y) )
  --assert("left inverse *", (1/x) * y = 1/(x * 1/y) )  -- y ~= 0
  --assert("left inverse /", (1/x) / y = 1/(x * y) )
  -- right
  --assert("right inverse +", x + (-y) = x - y )
  assert("right inverse -", x - (-y) = x + y )
  --assert("right inverse *", x * (1/y) = x / y )
  --assert("right inverse /", x / (1/y) = x * y )  -- y ~= 0

)abbrev domain SQ Squares
Squares():SquaresAxiom == add
  x:Symbolic(Integer,%) := coerce 'x
  assert("squares *", x*x = x^2 )

)abbrev domain AND /\
++ Conjunction of rules
_/_\(A:Axiom,B:Axiom):Axiom with
    if A has CommutativeAxiom_+ then CommutativeAxiom_+
    if B has CommutativeAxiom_+ then CommutativeAxiom_+
    if A has CommutativeAxiom_* then CommutativeAxiom_*
    if B has CommutativeAxiom_* then CommutativeAxiom_*
    if A has AntiCommutativeAxiom then AntiCommutativeAxiom
    if B has AntiCommutativeAxiom then AntiCommutativeAxiom
    if A has DistributiveAxiom then DistributiveAxiom
    if B has DistributiveAxiom then DistributiveAxiom
    if A has AssociativeAxiom then AssociativeAxiom
    if B has AssociativeAxiom then AssociativeAxiom
    if A has AssociativeAxiom_+ then AssociativeAxiom_+
    if B has AssociativeAxiom_+ then AssociativeAxiom_+
    if A has AssociativeAxiom_* then AssociativeAxiom_*
    if B has AssociativeAxiom_* then AssociativeAxiom_*
    if A has IdentityAxiom then IdentityAxiom
    if B has IdentityAxiom then IdentityAxiom
    if A has RightIdentityAxiom then RightIdentityAxiom
    if B has RightIdentityAxiom then RightIdentityAxiom
    if A has LeftIdentityAxiom then LeftIdentityAxiom
    if B has LeftIdentityAxiom then LeftIdentityAxiom
    if A has InverseAxiom then InverseAxiom
    if B has InverseAxiom then InverseAxiom
    if A has DoublesAxiom then DoublesAxiom
    if B has DoublesAxiom then DoublesAxiom
    if A has CancelsAxiom then CancelsAxiom
    if B has CancelsAxiom then CancelsAxiom
    if A has SquaresAxiom then SquaresAxiom
    if B has SquaresAxiom then SquaresAxiom
    if A has DividesAxiom then DividesAxiom
    if B has DividesAxiom then DividesAxiom
  == add
    x:Symbolic(Integer,%) := coerce 'x
    y:Symbolic(Integer,%) := coerce 'y
    z:Symbolic(Integer,%) := coerce 'z

    if % has CommutativeAxiom_* and % has AssociativeAxiom_* then
      assert("commutative-associative *",z*(x*y) = (x*z)*y )

)abbrev domain ASS Associative
Associative():AssociativeAxiom == Associative_+ /\ Associative_*

)abbrev domain ID Identities
Identities():IdentityAxiom == LeftIdentity /\ RightIdentity

)abbrev domain SEXPR SymbolicExpression
++ Description:
++ SymbolicExpression is a Symbolic domain with automatic rewrite rules that
++ approximate Expression itself.
SymbolicExpression(R:Comparable) : SymbolicCategory(R) == Implementation where
  --F ==> Expression R
  Implementation ==> Symbolic(R,Squares /\ _
    Inverse/\Identities/\ _
    Doubles/\Divides/\Distributive/\ _
    Commutative_+/\Commutative_*/\Cancels/\ _
    Associative_+/\Associative_*) add
    -- use equality from Expression(R)
    (x:% = y:%):Boolean ==
      --output("=",paren [x::OutputForm,y::OutputForm])$OutputPackage
      coerce(x)@Expression(R) = coerce(y)@Expression(R)

)abbrev package SYMPKG1 SymbolicFunctions1
SymbolicFunctions1(R: Join(Comparable,ConvertibleTo SIN), A:SymbolicCategory R,
  S: Join(Comparable,ConvertibleTo SIN), B:SymbolicCategory S): with
    convert: B -> A
  == add
    -- +0 is a hack to avoid premature conversion
    hack(x:B):SIN == binary(convert('_+),[convert x,0::SIN])
    convert(x:B):A ==
      v:List Symbol := variables(x)
      if #v = 0 then return interpret(hack x)$InputFormFunctions1(A)
      -- we need to substitute variables with unknown modes
      s:List Symbol := [new()$Symbol for vi in v]
      ks:List Equation B := [equation(coerce(vi)$B, coerce(si)$B) for vi in v for si in s]
      sk:List Equation A := [equation(coerce(si)$A, coerce(vi)$A) for vi in v for si in s]
      return subst(interpret(hack subst(x,ks))$InputFormFunctions1(A),sk)
