)abbrev domain SEXPR SymbolicExpression
++ Unevaluated mathematical expressions
++ Author: Bill Page
++ Date Created: 15 Novermber 2016
++ Description:
++ Expressions involving symbolic functions that remain unevaluated and are
++ displayed as entered. Evaluation is delayed until an operation is performed
++ which requires a canonical form such as testing for equality or
++ simplification. The domain depends directly internally on the Expression
++ domain for evaluation of expressions.
++ Keywords: expression, evaluation, operator, function.
SymbolicExpression(R : Join(Comparable,ConvertibleTo(InputForm))) : Exports == Implementation where
  F ==> Expression R
  K   ==> Kernel %
  MP  ==> SparseMultivariatePolynomial(R, K)
  AF  ==> AlgebraicFunction(R, %)
  EF  ==> ElementaryFunction(R, %)
  CF  ==> CombinatorialFunction(R, %)
  LF  ==> LiouvillianFunction(R, %)
  AN  ==> AlgebraicNumber
  KAN ==> Kernel AN
  ESD ==> ExpressionSpace_&(%)
  FSD ==> FunctionSpace_&(%, R)

  Exports ==> FunctionSpace R with
    if R has IntegralDomain then
      AlgebraicallyClosedFunctionSpace R
      TranscendentalFunctionCategory
      CombinatorialOpsCategory
      LiouvillianFunctionCategory
      SpecialFunctionCategory
      reduce : % -> %
        ++ reduce(f) simplifies all the unreduced algebraic quantities
        ++ present in f by applying their defining relations.
      number? : % -> Boolean
        ++ number?(f) tests if f is rational
      simplifyPower : (%, Integer) -> %
        ++ simplifyPower(f, n) \undocumented{}
      if R has PolynomialFactorizationExplicit then
          PolynomialFactorizationExplicit
      if R has RetractableTo Integer then RetractableTo AN
      setSimplifyDenomsFlag : Boolean -> Boolean
        ++ setSimplifyDenomsFlag(x) sets flag affecting simplification
        ++ of denominators.  If true irrational algebraics are removed from
        ++ denominators.  If false they are kept.
      getSimplifyDenomsFlag : () -> Boolean
        ++ getSimplifyDenomsFlag() gets values of flag affecting
        ++ simplification of denominators.  See setSimplifyDenomsFlag.

    --SymbolicExpression(R:Join(Comparable,ConvertibleTo(InputForm))):Join(Comparable,ConvertibleTo(InputForm)) with
    -- extra conversions
    convert: % -> Expression R
    coerce: F -> %
    coerce: Pi -> %
    -- Elementary Functions
    acos : % -> %
    acosh : % -> %
    acot : % -> %
    acoth : % -> %
    acsc : % -> %
    acsch : % -> %
    asec : % -> %
    asech : % -> %
    asin : % -> %
    asinh : % -> %
    atan : % -> %
    atanh : % -> %
    cos : % -> %
    cosh : % -> %
    cot : % -> %
    coth : % -> %
    csc : % -> %
    csch : % -> %
    exp : % -> %
    log : % -> %
    sec : % -> %
    sech : % -> %
    sin : % -> %
    sinh : % -> %
    sqrt : % -> %
    tan : % -> %
    tanh : % -> %
    -- transformations
    simplify : % -> %
    factor: % -> %
  Implementation ==> add
    Rep := InputForm
    if R has IntegralDomain then
      0:% == convert(0$F)@InputForm
      1:% == convert(1$F)@InputForm
      numer(x) == numer(convert(x)@F) pretend MP
      denom(x) == denom(convert(x)@F) pretend MP

    if F has FunctionSpace(Integer) then
      factor(x:%):% ==
        (factor(numer(convert(x)@F)$F)::OutputForm pretend InputForm /
          factor(denom(convert(x)@F)$F)::OutputForm pretend InputForm)$InputForm

    if R has Ring then
      coerce(x:MP):% == convert(x)@InputForm

    coerce(x:Pi):% == convert(x)@InputForm
    coerce1(x:Rep):OutputForm ==
      if null? x then return empty()$OutputForm
      if atom? x then return (x pretend OutputForm)
      if list? x and symbol? car x then
        s := symbol car x
        if s='float then return interpret(x)$InputFormFunctions1(Float)::OutputForm
        if member?(s,['_+,'_-,'_*,'_/,'_^])$List(Symbol) then
          return infix(outputForm(s)$OutputForm,
            [coerce1(i) for i in destruct cdr(x)])
        else
          return prefix(outputForm(s)$OutputForm,
            [coerce1(i) for i in destruct cdr(x)])
      return hconcat(message("what is:")$OutputForm,x pretend OutputForm)
    coerce(x:%):OutputForm == coerce1(x pretend Rep) -- x pretend OutputForm

    -- +0 is a hack to avoid premature conversion
    hack(x:%):Rep == binary(convert('_+),[x::Rep,0::Rep])$InputForm
    convert(x:%):F == interpret(hack x)$InputFormFunctions1(F)
    coerce(x:R):% == convert(x)@InputForm
    coerce(x:F):% == convert(x)@InputForm
    convert(x:%):InputForm == x pretend Rep
    --
    (x:% ^ y:%):% == binary(convert('_^),[x::Rep,y::Rep])$InputForm
    (x:% ^ y:PositiveInteger):% ==
      binary(convert('_^),[x::Rep,y::Rep])$InputForm
    (x:% ^ y:NonNegativeInteger):% ==
      binary(convert('_^),[x::Rep,y::Rep])$InputForm
    -- We don't want any InputForm +0 and *1 auto-simplification
    (x:% + y:%):% == binary(convert('_+),[x::Rep,y::Rep])$InputForm
    (x:% - y:%):% == binary(convert('_-),[x::Rep,y::Rep])$InputForm
    (x:% * y:%):% == binary(convert('_*),[x::Rep,y::Rep])$InputForm
    (x:% / y:%):% == binary(convert('_/),[x::Rep,y::Rep])$InputForm
    (x:Integer * y:%):% == convert(x)@InputForm * y
    _-(x:%):% == convert([convert('_-)@InputForm,x::Rep])
    -- Elementary Functions
    acos(x:%):% == convert([convert('acos)@InputForm,x::Rep])
    acosh(x:%):% == convert([convert('acosh)@InputForm,x::Rep])
    acot(x:%):% == convert([convert('acot)@InputForm,x::Rep])
    acoth(x:%):% == convert([convert('acoth)@InputForm,x::Rep])
    acsc(x:%):% == convert([convert('acsc)@InputForm,x::Rep])
    acsch(x:%):% == convert([convert('acsch)@InputForm,x::Rep])
    asec(x:%):% == convert([convert('asec)@InputForm,x::Rep])
    asech(x:%):% == convert([convert('asech)@InputForm,x::Rep])
    asin(x:%):% == convert([convert('asin)@InputForm,x::Rep])
    asinh(x:%):% == convert([convert('asinh)@InputForm,x::Rep])
    atan(x:%):% == convert([convert('atan)@InputForm,x::Rep])
    atanh(x:%):% == convert([convert('atanh)@InputForm,x::Rep])
    cos(x:%):% == convert([convert('cos)@InputForm,x::Rep])
    cosh(x:%):% == convert([convert('cosh)@InputForm,x::Rep])
    cot(x:%):% == convert([convert('cot)@InputForm,x::Rep])
    coth(x:%):% == convert([convert('coth)@InputForm,x::Rep])
    csc(x:%):% == convert([convert('csc)@InputForm,x::Rep])
    csch(x:%):% == convert([convert('csch)@InputForm,x::Rep])
    exp(x:%):% == convert([convert('exp)@InputForm,x::Rep])
    log(x:%):% == convert([convert('log)@InputForm,x::Rep])
    pi():% == convert([convert('pi)@InputForm])
    sec(x:%):% == convert([convert('sec)@InputForm,x::Rep])
    sech(x:%):% == convert([convert('sech)@InputForm,x::Rep])
    sin(x:%):% == convert([convert('sin)@InputForm,x::Rep])
    sinh(x:%):% == convert([convert('sinh)@InputForm,x::Rep])
    sqrt(x:%):% == convert([convert('sqrt)@InputForm,x::Rep])
    tan(x:%):% == convert([convert('tan)@InputForm,x::Rep])
    tanh(x:%):% == convert([convert('tanh)@InputForm,x::Rep])
    --
    retract(x:%):R == retract(convert(x)@F)$F
    variables(x:%):List Symbol == variables(convert x)$F
    -- use equality from Expression(R)
    (x:% = y:%):Boolean ==
      convert(x)@F = convert(x)@F

    if F has TranscendentalFunctionCategory then
      if F has FunctionSpace(Integer) then
        simplify(x:%):% ==
          convert(simplify(convert(x)@F)$TranscendentalManipulations(Integer,F))
      else
        if R has GcdDomain then
          simplify(x:%):% ==
            convert(simplify(convert(x)@F)$TranscendentalManipulations(R,F))
    else
      simplify(x:%):% == convert( convert(x)@F )
