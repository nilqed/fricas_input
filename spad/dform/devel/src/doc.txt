FriCAS :: DifferentialForms
***************************

Contents:

* 1.0 Introduction
* 1.1 Definitions

  * 1.1.1 Inner product of differential forms (**dot**)
  * 1.1.2. The volume form \eta (**volumeForm**)
  * 1.1.3. Hodge dual (**hodgeStar**)
  * 1.1.4 Interior product (**interiorProduct**)
  * 1.1.5 The Lie derivative (**lieDerivative**)

* Literature

* 2.0 Package Details
* 2.1 The metric g
* 2.2 Exported Functions

  * 2.2.1 Volume Form
  * 2.2.1 Scalar Product
  * 2.2.2 Hodge Star Operator
  * 2.2.3 Interior Product
  * 2.2.4 Lie Derivative
  * 2.2.5 Projection
  * 2.2.6 Monomials
  * 2.2.7 Atomize Basis Term
  * 2.2.8 Conjugate Basis Term
  * 2.2.9 Scalar and Vector Field
  * 2.2.10 Miscellaneous Functions

* 3.0 Implementation Notes

  * 3.1 Internal Representation
  * 3.2 dot :: inner product
  * 3.3 hodgeStar :: Hodge dual
  * 3.4 interiorProduct :: Interior product
  * 3.5 lieDerivative :: Lie derivative
  * 3.6 proj :: Projection

* 4.0 Examples
  * 4.1 Calculus in \mathbb{R}^3
  * 4.2 Faraday 2-form
  * 4.3 Some Examples from *Maple*
  * 4.4 More examples (way of working)
  

1.0 Introduction
****************

The package "DifferentialForms" (in file "dform.spad") builds on the
domain "DeRhamComplex". In the following section we give a brief
overview of the functions that are going to be implemented. The focus
is on precise definitions of the notions, since those may be varying
in the literature. In section (2) we will describe the exported
functions and how they work, in section (3) some short implementation
notes will be given and finally the last section is devoted to some
examples.


1.1 Definitions
***************

Let \mathcal{M} be a n-dimensional manifold (sufficiently smooth and
orientable). To each point P \in \mathcal{M} there is a neighborhood
which can be diffeomorphically mapped to some region in \mathbb{R}^n,
with coordinates

   x_1 (P'), \ldots, x_n (P')

for all P' \in \mathcal{U} (P) \subset \mathcal{M}. The tangent space
T_{P'} (\mathcal{M}) at the point P' is a vector space, that is
spanned by the basis

   e_1 (P'), \ldots, e_n (P')

which also is often denoted by

   \partial_1, \ldots, \partial_n =  \frac{\partial}{\partial x_1},
   \ldots,  \frac{\partial}{\partial x_n}.

A tangent vector v has the form

   v = \sum_{j = 1}^n v^j e_j .

The cotangent space T_{P'}^{} (\mathcal{M})^{\star} is the vector
space of linear functionals

   \alpha : T_{P'} (\mathcal{M}) \rightarrow \mathbb{R},

spanned by the basis e^1 (P'), \ldots, e^n (P') which (corresponding
to the basis \partial_j) is also denoted by

   d x^1,\ldots, d x^n.

The latter notation indicates the dependency on the moving point P'.
The dual basis is by definition comprised of those linear functionals
such that

   e^j (e_k) = \delta^j_k .

Therefore we have

   \alpha (v) = \alpha \left( \sum_{j = 1}^n v^j e_j \right) = \sum_{j
   = 1}^n v^j \alpha (e_j) = \sum_{j = 1}^n v^j \alpha_j,

where \alpha = \sum_{j = 1}^n \alpha_j e^j.


1.1.1 Inner product of differential forms (**dot**)
===================================================

Let g_x be a symmetric n \times n matrix which is nondegenerate (i.e.
\det (g_x) \neq 0). The index x indicates that this matrix depends on
the coordinates x_1 (P), \ldots, x_n (P) and may be varying from point
to point. If this dependency is smooth (enough) we speak of a
(pseudo-) Riemannian metric (locally). This way we get an isomorphism
between tangent vectors and 1-forms (= covectors):

   \alpha_j = g_{j k} v^k, \hspace{1.2em} v^j = g^{j k} \alpha_j .

Clearly, \sum_k g^{j k} g_{k l} = \delta^j_l, in other words (g^{j k})
is the inverse of g. The metric g defines an *inner product* of
vectors

   g (v, w) = \langle v, w \rangle : = g_{i j} v^i w^j

and by duality also on 1-forms:

   g^{- 1} (\alpha, \beta) = \langle \alpha, \beta \rangle : = g^{i j}
   \alpha_i \beta_j .

Now, this inner product is extended to arbitrary p-forms by

   \langle \alpha_1 \wedge \ldots \wedge \alpha_p , \beta_1 \wedge
   \ldots \wedge \beta_p \rangle : = \det (\langle \alpha_i, \beta_j
   \rangle) , \hspace{1.8em} (1 \leqslant i, j \leqslant p),
   \label{dot}

and linearity.


1.1.2. The volume form \eta (**volumeForm**)
============================================

The Riemannian *volume form* \eta is (by definition) given by the
n-form

   \eta = \sqrt{| \det g |} e^1 \wedge \ldots \wedge e^n = \sqrt{|
   \det\,g |} d x^1 \wedge \ldots \wedge d x^n . \label{vol}

This definition makes sense because by a (orientation preserving)
change of coordinates \sqrt{\mathrm{det} g} transforms like the
component of a n-form.


1.1.3. Hodge dual (**hodgeStar**)
=================================

The *Hodge dual* of a differential p-form \beta is the (n - p)-form
\star \beta such that

   \alpha \wedge \star \beta = \langle \alpha, \beta \rangle \eta
   \label{hodge}

holds, for all p-forms \alpha. The linear operator (\star) is called
the *Hodge star operator*. By the *Riesz representation theorem* the
Hodge dual is uniquely defined by the expression above.

**Warning**

Flanders [4] defines the Hodge dual by the equality

   \lambda \wedge \mu = \langle \star \lambda, \mu \rangle \eta

where \lambda is a p-form and \mu a (n - p)-form. This can result in
different signs (actually \star_F = s(g)\star, where s(g) is the sign
of the determinant of g).

The generally adopted definition (2016) is the one given at the
beginning of this subsection.

The components of \star \beta are

   (\star \beta)_{j_1, \ldots, j_{n - p}} = \frac{1}{p!}
   \varepsilon_{i_1,  \ldots, i_p, j_1, \ldots, j_{n - p}}  \sqrt{|
   \det g |} g^{i_1 k_1} \ldots  g^{i_p k_p} \beta_{k_1, \ldots, k_p}

what is equal to

   \frac{1}{p! \sqrt{| \det g |}} \varepsilon_{}^{k_1, \ldots, k_p,
   l_1,  \ldots, l_{n - p}} g_{j_1 l_1} \ldots g_{j_{n - p}, l_{n -
   p}} \beta_{k_1,  \ldots, k_p} .


1.1.4 Interior product (**interiorProduct**)
============================================

The *interior product* of a vectorfield v and a p-form \alpha is a (p
-1)-form i_v (\alpha) such that

   i_v (\alpha) (v_1, \ldots, v_{p - 1}) = \alpha (v, v_1, \ldots,
   v_{p - 1})

holds, for all vectorfields v_1, \ldots, v_{p - 1}. Therefore, the
components of i_v (\alpha) are

   i_v (\alpha)_{j_1, \ldots, j_{p - 1}} = v^j \alpha_{j, j_1, \ldots,
   j_{p -   1} .}

One can express the interior product by using the \star-operator. Let
\alpha be the 1-form defined by the equation

   \alpha (w) = g (v, w), \forall w.

That means in components: \alpha_j = g_{j k} v^k, thus we have

   i_v (\beta) = (-)^{p - 1} \star^{- 1} (\alpha \wedge \star \beta) .

Clearly, the interior product is independent of any metric, whereas
the Hodge operator is **not**! So, usually one should not use the
Hodge operator to compute the interior product.

We will use the fact that the interior product is an *antiderivation*,
which allows a recursive implementation.


1.1.5 The Lie derivative (**lieDerivative**)
============================================

The *Lie derivative* with respect to a vector field v can be
calculated (and defined) using Cartan's formula:

   \mathcal{L}_v \alpha = d i_v (\alpha) + i_v (d \alpha).

There are other ways to define \mathcal{L}_v \alpha, however, it is
convenient to compute it this way when d and i_v are already at hand.


Literature
**********

[1] Ralph Abraham, Jerrold E.Marsden and Tudor Ratiu.Manifolds,
    Tensor Analysis, and Applications. Springer, Auflage: 2nd
    Corrected ed. 1988. Corr. 2nd printing 1993 edition.

[2] Henri Cartan. Di erential Forms. Dover Pubn Inc, Au age: Tra
    edition.

[3] Herbert Federer. Geometric Measure Theory. Springer, Au age:
    Reprint of the 1st ed. Berlin, Heidelberg, New York 1969 edition.

[4] Harley Flanders and Mathematics. Differential Forms with
    Applications to the Physical Sciences. Dover Pubn Inc, Auflage:
    Revised. edition.

[5] L. A. Lambe and D. E. Radford. Introduction to the Quantum
    Yang- Baxter Equation and Quantum Groups:An Algebraic Approach.
    Springer, Auflage: 1997 edition.

[6] Walter Rudin and RudinWalter. Principles
    ofMathematicalAnalysis.Mcgraw Hill Book Co, Au age: Revised.
    edition.

[7] Hassler Whitney. Geometric Integration Theory: Princeton
    Mathematical Series, No. 21. Literary Licensing, LLC.
    

2.0 Package Details
*******************

Package Name:
   DifferentialForms

Abbreviation:
   DFORM

Source files:
   dform.spad

Dependent on:
   DeRhamComplex (DERHAM)

   DifferentialForms(R,v)

   R: Join(Ring,Comparable)   -- e.g. Integer
   v: List Symbol             -- e.g. [x,y,z] or [x[0],x[1],x[2]]

   X ==> Expression R         -- function Ring

For the examples following, we choose "R=Integer" and
"v=[x[0],x[1],x[2],x[3]]", and the abbreviation "M:=DFORM(R,v)".


2.1 The metric g
****************

Some functions expect the metric "g" as a parameter. Generally this
will be provided by an invertible square matrix
"g:SquareMatrix(#v,X)".

For the examples following, we choose the Minkowski metric::

   g := diagonalMatrix([-1,1,1,1])@SquareMatrix(4,Integer)

   \left[ \begin{array}{cccc} -1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0
   & 1 & 0 \\ 0 & 0 & 0 & 1 \end{array} \right]

_Type: SquareMatrix(4,Integer)


2.2 Exported Functions
**********************

The function **baseForms** return the basis one forms, while
**coordVector** returns a list of the coordinates. The function
**coordSymbols** also returns the coordinates, however, as symbols
only (convenient when used by **D**).

   SMR ==> SquareMatrix(#v,X)
   DRC ==> DeRhamComplex(R,v)

   dx:=baseForms()$M     -- [dx[0],...,dx[3]]
   x:=coordVector()$M    -- [x[0],...,x[3]]
   xs:=coordSymbols()$M  -- as above but as List Symbol (for differentiation)


2.2.1 Volume Form
=================

**volumeForm**
   Given a metric g the function returns the corresponding volume
   element of the Riemannian (pseudo-) manifold.

   volumeForm : SquareMatrix(#v,X) -> DeRhamComplex(R,v)

   volumeForm(g)$M

   {dx _ {0}} \  {dx _ {1}} \  {dx _ {2}} \  {dx _ {3}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.1 Scalar Product
====================

**dot**
   Compute the inner product of two differential forms with respect to
   the metric "g".

   dot : (SMR,DRC,DRC) -> X

   dot(g,dx.1*dx.2,dx.1*dx.2)$M   -- note dx.1 corresponds to dx[0].

   - 1

_Type: Expression(Integer)


2.2.2 Hodge Star Operator
=========================

**hodgeStar**
   Compute the Hodge dual form of a differential form with respect to
   a metric "g".

   hodgeStar : (SMR,DRC) -> DRC

   hodgeStar(g,dx.2 * dx.3)

   {dx _ {0}} \  {dx _ {3}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.3 Interior Product
======================

**interiorProduct**
   Calculate the interior product i_X(a) of the vector field X with
   the differential form a.

   interiorProduct : (Vector(X),DRC) -> DRC

   interiorProduct(vector x, dx.1*dx.3)$M

   {{x _ {0}} \  {dx _ {2}}} -{{x _ {2}} \  {dx _ {0}}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.4 Lie Derivative
====================

**lieDerivative**
   Calculates the Lie derivative \mathcal{L}_X(a) of the differential
   form a with respect to the vector field X.

   lieDerivative : (Vector(X),DRC) -> DRC

   lieDerivative(vector x, dx.1 * dx.3 * dx.4)

   3 \  {dx _ {0}} \  {dx _ {2}} \  {dx _ {3}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.5 Projection
================

**proj**
   Project to homogeneous terms of degree p.

   NNI ==> NonNegativeInteger
   proj : (NNI,DRC) -> DRC

   proj(2, 2*dx.1 + dx.2*dx.3 - dx.3*dx.4)

   -{{dx _ {2}} \  {dx _ {3}}}+{{dx _ {1}} \  {dx _ {2}}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.6 Monomials
===============

**monomials**
   List all monomials of degree p (p in 1..n). This is a basis for
   \Lambda_p^n.

   monomials : NNI -> List DRC

   monomials(3)$M

   \left[ {{dx _ {0}} \  {dx _ {1}} \  {dx _ {2}}}, \: {{dx _ {0}} \
   {dx _ {1}} \  {dx _ {3}}}, \: {{dx _ {0}} \  {dx _ {2}} \  {dx _
   {3}}}, \: {{dx _ {1}} \  {dx _ {2}} \  {dx _ {3}}} \right]

_Type: List DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.7 Atomize Basis Term
========================

**atomizeBasisTerm**
   Given a basis term, return a list of the generators (atoms).

   atomizeBasisTerm : DRC -> List DRC

   atomizeBasisTerm(dx.1 * dx.2 * dx.4)

   \left[  {dx _ {0}}, \: {dx _ {1}}, \: {dx _ {3}} \right]

_Type: List(DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]]))


2.2.8 Conjugate Basis Term
==========================

**conjBasisTerm**
   Return the complement of a basis term with respect to the Euclidean
   volume form.

   conjBasisTerm : DRC -> DRC

   conjBasisTerm dx.4

   {dx _ {0}} \  {dx _ {1}} \  {dx _ {2}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])


2.2.9 Scalar and Vector Field
=============================

**vectorField**
   Generate a generic vector field named by a given symbol.

**covectorField**
   Generate a generic co-vector field named by a given symbol.

**scalarField**
   Generate a generic scalar field named by a given symbol.

   vectorField   : Symbol -> List X
   covectorField : Symbol -> List DRC
   scalarField   : Symbol -> X

   vectorField(Q)$M
   scalarField(f)$M

   \left[ {{Q _ {1}} \left( {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \:
   {x _ {3}}} \right)}, \: {{Q _ {2}} \left( {{x _ {0}}, \: {x _ {1}},
   \: {x _ {2}}, \: {x _ {3}}} \right)}, \: {{Q _ {3}} \left( {{x _
   {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}, \: {{Q _
   {4}} \left( {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)} \right]

_Type: List(Expression(Integer))

   f \left(  {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)

_Type: Expression(Integer)


2.2.10 Miscellaneous Functions
==============================

A *zero form* with symbol s can be generated by

   zeroForm : Symbol -> DRC

   zeroForm(s)$M

   s \left(  {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])

A synonym for the **exteriorDerivative** is the common operator **d**:

   d : DRC -> DRC

   d zeroForm(f)$M

   {{{f _ {{,4}}} \left( {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x
   _ {3}}} \right)} \  {dx _ {3}}}+{{{f _ {{,3}}} \left( {{x _ {0}},
   \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {dx _ {2}}}+
   \\ {{{f _ {{,2}}} \left( {{x _ {0}}, \: {x _ {1}}, \: {x _ {2}}, \:
   {x _ {3}}} \right)} \  {dx _ {1}}}+{{{f _ {{,1}}} \left( {{x _
   {0}}, \: {x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {dx _
   {0}}}

The special zero forms **0** and **1** can be generated by

   one :  -> DRC
   zero : -> DRC

   zero()$M
   one()$M

There are also some special multiplication operators which allow to
deal with a kind *vector valued* forms (actually lists):

   _* : (List X, List DRC)   -> DRC
   _* : (List DRC, List DRC) -> DRC

   Note: the lists must have dimension #v.

   For instance:

   x * dx

   {{x _ {3}} \  {dx _ {3}}}+{{x _ {2}} \  {dx _ {2}}}+{{x _ {1}} \
   {dx _ {1}}}+{{x _ {0}} \  {dx _ {0}}}

An example for the second case:

   dx*[hodgeStar(g,dx.j)$M for j in 1..4]

   2 \  {dx _ {0}} \  {dx _ {1}} \  {dx _ {2}} \  {dx _ {3}}

_Type: DeRhamComplex(Integer,[x[0],x[1],x[2],x[3]])



3.0 Implementation Notes
************************

In this section some implementation details will be described. This is
a ongoing process and might be improved.


3.1 Internal Representation
===========================

Differential forms are represented as "List Record(k:EAB, c:R)" where
each basic term is represented as "Record(k:EAB, c:R)", for instance:

   h (x, y, z)\ dz + g (x, y, z)\ dy + f (x, y, z)\ dx

maps to

   [[k= [0,0,1],c= h(x,y,z)],[k= [0,1,0],c= g(x,y,z)],[k= [1,0,0],c= f(x,y,z)]]

or, another example:

   c (x, y, z)\ dy\ dz + b (x, y, z)\ dx\ dz + a (x, y, z)\ dx\ dy

goes to

   [[k= [0,1,1],c= c(x,y,z)],[k= [1,0,1],c= b(x,y,z)],[k= [1,1,0],c= a(x,y,z)]]

It is easily seen that for n generators x_1, \ldots, x_n the term d
x_{j_p} \wedge \ldots \wedge d x_{j_q} is represented by [k =
[a_{i_1}, \ldots, a_{i_n}], c = \pm 1] where a_{i_s} \in \{ 0, 1 \}
depending on whether d x_{i_s} is contained in the term or not. The
(local) function **terms** sends a differential form \omega to the
representation r (\omega). Note that the operations are destructive,
this means that one has to copy the objects in order to get new ones
(mere assignment inherits all previous changes).

**Note**
   The interpreter normalizes the basic terms according to increasing
   generators, i.e for example: d x_3 \wedge d x_2 will be stored as -
   d x_2 \wedge d x_3, whereby the signum of the permutation is
   calculated and transferred to the "c"-field in the record.

Example:

   terms(dx3*dx2) -> [[k= [0,1,1],c= - 1]]


3.2 dot :: inner product
========================

Given a (pseudo)-Riemannian metric g, the scalar product of two basic
terms of the same degree is given by

   \langle d x_{i_1} \ldots d x_{i_p}, d x_{j_1} \ldots d x_{j_p}
   \rangle =   \det (\langle d x_{i_k} , d x_{j_l} \rangle) = \det
   (g^{- 1} (i_k,   j_l)),

whereby 1 \leqslant k, l \leqslant p. Note that g^{- 1} (i_k, j_l) =
g^{i_k j_l} is the inverse of g_{i_k j_l} (raised indexes as usual).
In other words, the scalar product is inherited from the dual vector
space of the space where the coordinates (x_1, \ldots, x_n) live, and
is continued by linearity. By the way, terms of different **degree**
are considered to be *orthogonal* to each other.

Example:

   [x,y,z], G = matrix(G[i,j]) = g^{- 1},

   \langle d x \wedge d y, d y \wedge d z \rangle = \langle d x, d y
   \rangle   \langle d y, d z \rangle - \langle d x, d z \rangle
   \langle d y, d y   \rangle = \\ {G[1,2] G[2, 3] - G[1, 3] G[2, 2]}

The corresponding EAB's are "[1,1,0]" and "[0,1,1]". If we define a
function **pos** which gives the positions of 0 or 1 respectively, the
example tells us:

   pos([1,1,0],1)=[1,2] and pos([0,1,1],1)=[2,3]

so that the direct product of the two resulting lists gives the
desired minor:

   [1,2]x[2,3]=[[1,2],[1,3],[2,2],[2,3]] =>

    \left|\begin{array}{c}   G_{12} G_{1 3}\\   G_{2 2} G_{2 3}
   \end{array}\right| .

This essentially comprises the method we will use to compute the
scalar product w.r.t symmetric matrices g and two basic terms of equal
degree.

Local function: **dot2**

* compute the inverse of tmverbatim{g}.

* build the tmverbatim{pos} lists.

* build the minor and apply "determinant".

Actually there are two functions **dot1** and **dot2**, where the
former is used when the metric g is *diagonal* (which is equivalent to
the basis vectors being orthogonal) because the performance might be
better if the dimension of the space is huge.


3.3 hodgeStar :: Hodge dual
===========================

In this new version we have removed the first method (3.3.1) because
the performance difference is not as significant as we thought in the
first place, at least not for n\leq 7. However, we save the method in
case someone has to deal with really high space dimensions.


3.3.1 Diagonal, non-degenerated g
---------------------------------

If g is a diagonal matrix then the components of \star \beta reduce to

   (\star \beta)_{j_1, \ldots, j_{n - p}} = \frac{1}{p!}
   \varepsilon_{k_1,   \ldots, k_p, j_1, \ldots, j_{n - p}}  \sqrt{|
   \det g |}  [g^{k_1 k_1}   \ldots g^{k_p k_p}] \beta_{k_1, \ldots,
   k_p}

which implies that (j_1, \ldots, j_{n - p}) must be the complement of
(k_1,\ldots, k_p) in \{ 1, 2, \ldots, n \} and

   \star (d x_{k_1} \wedge \ldots \wedge d x_{k_p}) = C d x_{j_1}
   \wedge  \ldots \wedge d x_{j_{n - p}}

for some (yet unknown) factor "C" which must actually be equal to the
right hand side of the component formula above. When we recollect the
internal representation of d x_{k_1} \wedge \ldots \wedge d x_{k_p} as
EAB then it is easy to get the complement by flipping the 0 and 1.
Define a function **flip** such that

   \mathrm{flip} (d x_{k_1} \wedge \ldots \wedge d x_{k_p}) = d
   x_{j_1} \wedge \ldots \wedge d x_{j_{n - p}}

then by using the Hodge formula with \alpha = \beta = dx_{k_1} \wedge
\ldots \wedge d x_{k_p} we get using \star \alpha = C\ \mathrm{flip}
(\alpha):

   C \alpha \wedge \mathrm{flip} (\alpha) = \langle \alpha, \alpha
   \rangle \eta  = \langle \alpha, \alpha \rangle \sqrt{| \det (g) |}
   d x_1 \wedge \ldots  \wedge d x_n .

Since \alpha \wedge \mathrm{flip} (\alpha) is a n-form, the function
**leadingCoefficient** returns the one and only coefficient. Thus we
can calculate "C" to

   C = \frac{\langle \alpha, \alpha \rangle \sqrt{| \det (g)
   |}}{\mathtt{leadingCoefficient} (\alpha \wedge \mathrm{flip}
   (\alpha))} .

In **SPAD** syntax this looks like:

   \mathtt{C =}  \frac{\mathtt{dot} (\alpha, \alpha) \star  \mathtt{s
   qrt\left(abs\left(\right.determinant\left(g\right)\right)}}{\matht
   t{leadingCoefficient}  \left( \alpha \star \mathtt{flip} (\alpha)
   \right)} .

This way the interpreter saved us the tedious computation of the
permutation signatures. Moreover, we have not to care whether the
metric g is positive or negative definite.


3.3.2 General case
------------------

Let J denote an ordered multi-index and J_\sharp its dual. Then a
generic p-vector may be written as

   \beta = \sum_{|J|=p} b^J \ e_J.

Thus by definition we obtain:

   \alpha\wedge\star\beta=(\alpha,\beta)\,\eta \Rightarrow
   e_J\wedge\star\beta=(e_J,\beta)\,\eta

Since \star\beta is a (n-p)-form, we get:

   \star\beta=\sum_{|K|=n-p} a^K e_K \Rightarrow \sum_{|K|=n-p} a^K
   e_J\wedge e_K=\sum_{|I|=p} b^I (e_J,e_I)= \sum_{|I|=p} g_{JI} b^I
   \eta = b_J \eta.

Now the term e_J\wedge e_K is non-zero only if K=J_\sharp, therefore

   a^{J_\sharp} =\sqrt{g}\, \epsilon(J)\, \sum_{|I|=p} g_{JI} b^I

where e_J\wedge e_{J_\sharp}=\epsilon(J)\, \eta\  defines \epsilon.

If we choose \beta=e_M we finally get

   \star e_M = \sqrt{g} \sum_{|J|=p} \epsilon(J)\, g_{JM}\,
   e_{J_\sharp}.

This formula will be used to compute the Hodge dual for *monomials*.
We define a function **hodgeBT**, in pseudo-code:

   hodgeStarBT(dx[M])= sqrt(g)*
        SUM[J] {eps(dx[J])*dot(g,dx[J],dx[M])*conjBasisTerm(dx[j])}

which then allows to compute the Hodge dual of any form by simple
recursion:

   hodgeStar(g:SMR,x:DRC):DRC ==
     x=0$DRC => x
     leadingCoefficient(x) * hodgeStarBT(g,leadingBasisTerm(x)) + _
       hodgeStar(g, reductum(x))


3.4 interiorProduct :: Interior product
=======================================

In this newer version we have replaced the method which uses the Hodge
operator. Instead we used the fact that the interior product is an
*antiderivation*, actually the unique antiderivation of degree -1 on
the exterior algebra such that i_X(\alpha)=\alpha(X):

   i_X(\beta\wedge\gamma)=i_X(\beta)\wedge\gamma)+  (-1)^{{\mathtt
   deg}\, \beta}\ \beta\wedge i_X(\gamma)

This also allows an easy implementation by recursion.


3.5 lieDerivative :: Lie derivative
===================================

Here we use *Cartan's formula* (see 1.1.5), so that there is not much
to say.

   lieDerivative(w:Vector X,x:DRC):DRC ==
     a := exteriorDifferential(interiorProduct(w,x))
     b := interiorProduct(w, exteriorDifferential(x))
     a+b


3.6 proj :: Projection
======================

Since the elements of \mathtt{DeRhamComplex} are in

   X = \bigoplus_{p = 0}^n \Omega^p (V)

it is convenient to have a function \mathtt{proj}:\{ 0, \ldots,n
\}\times X \rightarrow X which returns the projection on the
homogeneous component \Omega^p (V). The implementation is
straightforward when using the internals of EAB. Probably there are
better ways to do this, especially by using exported functions only.

   ** deprecated **
   proj(x,p) ==
     t:List REA := x::List REA
     idx := [j for j in 1..#t | #pos(t.j.k,1)=p]
     s := [copy(t.j) for j in idx::List(NNI)]
     convert(s)$DRC

**NEW**

In the new version we actually replaced the function above by the
following recursive one:

   proj(p,x) ==
     x=0 => x
     homogeneous? x and degree(x)=p => x
     a:=leadingBasisTerm(x)
     if degree(a)=p then
       leadingCoefficient(x)*a + proj(p, reductum x)
     else
       proj(p, reductum x)

**NOTE** We have changed the order of arguments from (DRC,NNI) to
(NNI,DRC) because this corresponds more to the usual nomenclature of
projections.


4.0 Examples
************

In this chapter some examples are provided.


4.1 Calculus in \mathbb{R}^3
============================

We will prove the following identities (see the summary, 4.1.4, for
details):

   d\,f = [\mathtt{grad}\,f]_1 \\ d\,[T]_1 = [\mathtt{curl}\,T]_2 \\
   d\,[T]_2 = [\mathtt{div}\,T]_3

Let M denote our differential graded algebra on \mathbb{R}^3. In
FriCAS we can express this as

   M ==> DFORM(INT,[x,y,z])

   \mathtt{DifferentialForms(Integer,[x,y,z])}

_Type: Type

The list of available methods can be seen by

   )show M

   DifferentialForms(Integer,[x,y,z]) is a package constructor.
   Abbreviation for DifferentialForms is DFORM
   This constructor is exposed in this frame.
   ------------------------------- Operations --------------------------------

   coordSymbols : () -> List(Symbol)
   ...
   baseForms : () -> List(DeRhamComplex(Integer,[x,y,z]))
   coordVector : () -> List(Expression(Integer))
   .
   .
   .

The position vector P=(x,y,z) and the basis of one forms can be
obtained by

   P:=coordVector()$M

   [x,y,z]

_Type: List(Expression(Integer))

and

   dP:=baseForms()$M

   [dx,dy,dz]

_Type: List(DeRhamComplex(Integer,[x,y,z]))

This way we can call the coordinates as P.i and the basis one forms as
dP.i. Of course, we can also use dx,dy,dz directly when we set

   [dx,dy,dz]:=baseForms()$M

or when we use the generators of the domain "DeRhamComplex" itself:

   dx:=generator(1)$DERHAM(INT,[x,y,z])
   dy:= ...

The first method, however, is quite convenient when using indexed
coordinates and also because we can form expressions like

   P * dP

   z\ dz + y\ dy + x\ dx

_Type: DeRhamComplex(Integer,[x,y,z]).


4.1.1 Gradient
--------------

There are many ways to create a zero form, one of those is

   f := zeroForm(f)$M

   f(x,y,z)

_Type: DeRhamComplex(Integer,[x,y,z])

Now we apply the exterior differential operator to f:

   d f

   {{{f _ {{,3}}} \left( {x, \: y, \: z} \right)} \  dz}+{{{f _
   {{,2}}} \left( {x, \: y, \: z} \right)} \  dy}+{{{f _ {{,1}}}
   \left( {x, \: y, \: z} \right)} \  dx}

_Type: DeRhamComplex(Integer,[x,y,z])

The coefficients of df are just

   [coefficient(d f, dP.j) for j in 1..3]

    \left[  {{f _ {{,1}}}  \left(  {x, \: y, \: z}  \right)},  \: {{f
   _ {{,2}}}  \left(  {x, \: y, \: z}  \right)},  \: {{f _ {{,3}}}
   \left(  {x, \: y, \: z}  \right)} \right]

_Type: List(Expression(Integer))

the components of the gradient vector \nabla f of f.


4.1.2 Curl
----------

Let T be a generic vector field on M=\mathbb{R}^3:

   T := vectorField(T)$M

   \left[ {{T _ {1}} \left( {x, \: y, \: z} \right)}, \: {{T _ {2}}
   \left( {x, \: y, \: z} \right)}, \: {{T _ {3}} \left( {x, \: y, \:
   z} \right)} \right]

_Type: List(Expression(Integer))

Then we build the general one form \tau:

   tau := T * dP

Now we apply the exterior differential operator d:

   d tau

   \small{ {{\left( {{{T _ {3}} _ {{,2}}} \left( {x, \: y, \: z}
   \right)} -{{{T _ {2}} _ {{,3}}} \left( {x, \: y, \: z} \right)}
   \right)} \  dy \  dz}+{{\left( {{{T _ {3}} _ {{,1}}} \left( {x, \:
   y, \: z} \right)} -{{{T _ {1}} _ {{,3}}} \left( {x, \: y, \: z}
   \right)} \right)} \  dx \  dz}+  \\ {{\left( {{{T _ {2}} _ {{,1}}}
   \left( {x, \: y, \: z} \right)} -{{{T _ {1}} _ {{,2}}} \left( {x,
   \: y, \: z} \right)} \right)} \  dx \  dy} }

_Type: DeRhamComplex(Integer,[x,y,z])

Next, we want to extract the coefficients:

   [coefficient(d tau, m) for m in monomials(2)$M]

   \small{ \left[ {{{{T _ {2}} _ {{,1}}} \left( {x, \: y, \: z}
   \right)} -{{{T _ {1}} _ {{,2}}} \left( {x, \: y, \: z} \right)}},
   \: {{{{T _ {3}} _ {{,1}}} \left( {x, \: y, \: z} \right)} -{{{T _
   {1}} _ {{,3}}} \left( {x, \: y, \: z} \right)}}, \: {{{{T _ {3}} _
   {{,2}}} \left( {x, \: y, \: z} \right)} -{{{T _ {2}} _ {{,3}}}
   \left( {x, \: y, \: z} \right)}} \right]}

The (well known) **curl** is defined as

   \mathtt{curl}(T) =\nabla\times T= \small{ \left( \frac{\partial
   T_3}{\partial y} - \frac{\partial T_2}{\partial z}, \frac{\partial
   T_1}{\partial z} - \frac{\partial T_3}{\partial x}, \frac{\partial
   T_2}{\partial x} - \frac{\partial T_1}{\partial y} \right)}

   curl(V) == [D(V.3,y)-D(V.2,z),D(V.1,z)-D(V.3,x),D(V.2,x)-D(V.1,y)]

We now **claim** that the following identity holds:

   d (T\, dP) =  \star(\mathtt{curl}(V)\, dP)

where "*" denotes the Hodge star operator with respect to the
Euclidean metric

   g:=diagonalMatrix([1,1,1])

   \left[ \begin{array}{ccc} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1
   \end{array} \right]

To prove it we just have to test:

   test( d(T*dP) = hodgeStar(g,curl(T)*dP)$M )

   \mathtt{true}

_Type: Boolean


4.1.3 Divergence
----------------

Again, let T be a generic vector field on M=\mathbb{R}^3, then the
divergence is defined by

   \mathtt{div}(T) = \nabla \bullet T = \small{ \frac{\partial
   T_1}{\partial x} + \frac{\partial T_2}{\partial y} + \frac{\partial
   T_3}{\partial z}}.

When we calculate

   d hodgeStar(g, T*dP)$M

we get the 3-form

   {\left( {{{T _ {3}} _ {{,3}}} \left( {x, \: y, \: z} \right)}+{{{T
   _ {2}} _ {{,2}}} \left( {x, \: y, \: z} \right)}+{{{T _ {1}} _
   {{,1}}} \left( {x, \: y, \: z} \right)} \right)} \  dx \  dy \  dz


4.1.4 Summary
-------------

Let us summarize what we have obtained above. We use the following
notation for the mapping of scalar functions and vector fields to
differential forms:

   f \rightarrow [f]_0 \\ T \rightarrow [T]_1

where the index denotes the degree of the form. Moreover, we define
another pair of forms by applying the Hodge operator:

   [T]_2 = \star [T]_1 \\ [f]_3 = \star [f]_0

So we can state the general identities:

   d\,f = [\nabla\,f]_1 \\ d\,[T]_1 = [\mathtt{curl}\,T]_2 \\ d\,[T]_2
   = [\mathtt{div}\,T]_3


4.1.5 Hodge duals
-----------------

To conclude this example, we are going to calculate a table for the
Hodge duals of the monomials.

   g:=diagonalMatrix([1,1,1])::SquareMatrix(3,INT)

   [[hodgeStar(g,m)$M for m in monomials(j)$M] for j in 0..3]

   \left[ {\left[ {dx \  dy \  dz} \right]}, \: {\left[ {dy \  dz}, \:
   -{dx \  dz}, \: {dx \  dy} \right]}, \: {\left[ dz, \: -dy, \: dx
   \right]}, \: {\left[ 1 \right]} \right]

_Type: List(List(DeRhamComplex(Integer,[x,y,z])))

Thus we get the following table:

+----------------+-------------------------------+--------------------------+
| \alpha         | \star\alpha                   | \star\star\alpha         |
+================+===============================+==========================+
| 1              | dx\wedge dy \wedge dz         | 1                        |
+----------------+-------------------------------+--------------------------+
| dx             | dy \wedge dz                  | dx                       |
+----------------+-------------------------------+--------------------------+
| dy             | -dx \wedge dz                 | dy                       |
+----------------+-------------------------------+--------------------------+
| dz             | dx \wedge dy                  | dz                       |
+----------------+-------------------------------+--------------------------+

By the way, this method can be applied in any dimension for any
metric.


4.2 Faraday 2-form
==================

The free electromagnetic field can be described by a 2-form **F** in
Minkowski space. This form - also known as Faraday 2-form - is given
by

   \small{ F=B_1\ dy\wedge dz + B_2\ dz\wedge dx + B_3\ dx\wedge dy +
   E_1\ dx\wedge dt + E_2\ dy\wedge dt + E_3\ dz\wedge dt }

where we here use the **cgs** system and **E**, **B** denote the
classical fields (see the example in the documentation of
"DeRhamComplex").

To represent **F** in FriCAS we have to choose space-time variables
x,y,z,t, in the correct order, and g will be the Minkowski metric:

   v := [x,y,z,t]

   g := diagonalMatrix([-1,-1,-1,1])::SquareMatrix(4,INT)

   M := DFORM(INT,v)

   R ==> EXPR(INT)

Instead of x,y,z,t we also could have chosen x_0,x_1,x_2,x_3 for
instance. Now we need the coordinates and basis one forms:

**Important**
   The order of the variables must coincide with that in the metric g.
   That means for example, for t,x,y,z the positive "1" comes first.

   X := coordVector()$M

   dX := baseForms()$M

We also need the field **E** and **B**, but this time we will not
choose the "vectorField" function because we only need three
components:

   E := [operator E[i] for i in 1..3]
   B := [operator B[i] for i in 1..3]

Eventually we can build **F**:

   F := (B.1 X)*dX.2*dX.3 + (B.2 X)*dX.3*dX.1 + (B.3 X)*dX.1*dX.2 +_
        (E.1 X)*dX.1*dX.4 + (E.2 X)*dX.2*dX.4 + (E.3 X)*dX.3*dX.4

   \small{ {{{E _ {3}} \left( {x, \: y, \: z, \: t} \right)} \  dz \
   dt}+{{{E _ {2}} \left( {x, \: y, \: z, \: t} \right)} \  dy \
   dt}+{{{B _ {1}} \left( {x, \: y, \: z, \: t} \right)} \  dy \  dz}
   + \\ {{{E _ {1}} \left( {x, \: y, \: z, \: t} \right)} \  dx \  dt}
   -{{{B _ {2}} \left( {x, \: y, \: z, \: t} \right)} \  dx \
   dz}+{{{B _ {3}} \left( {x, \: y, \: z, \: t} \right)} \  dx \  dy}
   }

_Type: DeRhamComplex(Integer,[x,y,z,t])

We apply the exterior differential operator **d** to **F**:

   d F

   \small{   {{\left( {{{E _ {3}} _ {{,2}}}   \left(   {x, \: y, \: z,
   \: t}   \right)}   -{{{E _ {2}} _ {{,3}}}   \left(   {x, \: y, \:
   z, \: t}   \right)}+{{{B   _ {1}} _ {{,4}}}   \left(   {x, \: y, \:
   z, \: t}   \right)}   \right)}   \  dy \  dz \  dt}\, + \\
   {{\left( {{{E _ {3}} _ {{,1}}}   \left(   {x, \: y, \: z, \: t}
   \right)}   -{{{E _ {1}} _ {{,3}}}   \left(   {x, \: y, \: z, \: t}
   \right)}   -{{{B _ {2}} _ {{,4}}}   \left(   {x, \: y, \: z, \: t}
   \right)}   \right)}   \  dx \  dz \  dt}\, + \\   {{\left( {{{E _
   {2}} _ {{,1}}}   \left(   {x, \: y, \: z, \: t}   \right)}   -{{{E
   _ {1}} _ {{,2}}}   \left(   {x, \: y, \: z, \: t}   \right)}+{{{B
   _ {3}} _ {{,4}}}   \left(   {x, \: y, \: z, \: t}   \right)}
   \right)}   \  dx \  dy \  dt}\, + \\   {{\left( {{{B _ {3}} _
   {{,3}}}   \left(   {x, \: y, \: z, \: t}   \right)}+{{{B   _ {2}} _
   {{,2}}}   \left(   {x, \: y, \: z, \: t}   \right)}+{{{B   _ {1}} _
   {{,1}}}   \left(   {x, \: y, \: z, \: t}   \right)}   \right)}   \
   dx \  dy \  dz}   }

_Type: DeRhamComplex(Integer,[x,y,z,t])

We see at once that the first three terms of the sum correspond to the
vector

   \nabla\times\mathbf{E}+\frac{\partial\mathbf{B}}{\partial t}

and the fourth term is

   \nabla\bullet\mathbf{B}.

Actually, all terms are zero by two of the *Maxwell* equations.
Consequently we have shown (the well known fact)

   d\mathbf{F} = 0

Now let us apply the \star-operator to **F**, which is also a 2-form:

   %F := hodgeStar(g,F)$M

   \small{  {{{B _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}  \
   dz \  dt} + {{{B _ {2}}  \left(  {x, \: y, \: z, \: t}  \right)}  \
   dy \  dt} -{{{E _ {1}}  \left(  {x, \: y, \: z, \: t}  \right)}  \
   dy \  dz}+ \\  {{{B _ {1}}  \left(  {x, \: y, \: z, \: t}  \right)}
   \  dx \  dt} + {{{E _ {2}}  \left(  {x, \: y, \: z, \: t}  \right)}
   \  dx \  dz}- {{{E _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}
   \  dx \  dy}  }

_Type: DeRhamComplex(Integer,[x,y,z,t])

Now, as before:

   d %F

   \small{ {{\left( -{{{E _ {1}} _ {{,4}}} \left( {x, \: y, \: z, \:
   t} \right)}+{{{B _ {3}} _ {{,2}}} \left( {x, \: y, \: z, \: t}
   \right)} -{{{B _ {2}} _ {{,3}}} \left( {x, \: y, \: z, \: t}
   \right)} \right)} \  dy \  dz \  dt}+ \\ {{\left( {{{E _ {2}} _
   {{,4}}} \left( {x, \: y, \: z, \: t} \right)}+{{{B _ {3}} _ {{,1}}}
   \left( {x, \: y, \: z, \: t} \right)} -{{{B _ {1}} _ {{,3}}} \left(
   {x, \: y, \: z, \: t} \right)} \right)} \  dx \  dz \  dt}+ \\
   {{\left( -{{{E _ {3}} _ {{,4}}} \left( {x, \: y, \: z, \: t}
   \right)}+{{{B _ {2}} _ {{,1}}} \left( {x, \: y, \: z, \: t}
   \right)} -{{{B _ {1}} _ {{,2}}} \left( {x, \: y, \: z, \: t}
   \right)} \right)} \  dx \  dy \  dt}+ \\ {{\left( -{{{E _ {3}} _
   {{,3}}} \left( {x, \: y, \: z, \: t} \right)} -{{{E _ {2}} _
   {{,2}}} \left( {x, \: y, \: z, \: t} \right)} -{{{E _ {1}} _
   {{,1}}} \left( {x, \: y, \: z, \: t} \right)} \right)} \  dx \  dy
   \  dz} }

_Type: DeRhamComplex(Integer,[x,y,z,t])

Again, we see that the first three terms correspond to

   -\frac{\partial\mathbf{E}}{\partial t}+ \nabla\times\mathbf{B}

while the last one corresponds to:

   -\,\nabla\bullet\mathbf{E}

Thus, in vacuum, these are the second pair of *Maxwell's* equation and
we have:

   d \star\mathbf{F} = 0

To conclude this example we will compute the quantities (4-forms):

   \mathbf{F} \wedge \mathbf{F} \ \ \mathrm{and} \ \ \mathbf{F} \wedge
   \star\mathbf{F}.

Recalling the definition of the Hodge dual it is sufficient (in
principle) to compute the scalar product \langle F,F\rangle:

   dot(g,F,F)$M

   \small{  -{{{{E _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^
   {2}} -{{{{E _ {2}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^
   {2}} -{{{{E _ {1}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^
   {2}}+ \\  {{{{B _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^
   {2}}+{{{{B _ {2}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^
   {2}}+{{{{B _ {1}}  \left(  {x, \: y, \: z, \: t}  \right)}}  ^ {2}}
   }

_Type: Expression(Integer)

and \langle F,\star F\rangle:

   dot(g,F,%F)$M

   \small{  -{2 \  {{B _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}
   \  {{E _ {3}}  \left(  {x, \: y, \: z, \: t}  \right)}}  -{2 \  {{B
   _ {2}}  \left(  {x, \: y, \: z, \: t}  \right)}  \  {{E _ {2}}
   \left(  {x, \: y, \: z, \: t}  \right)}}  -{2 \  {{B _ {1}}  \left(
   {x, \: y, \: z, \: t}  \right)}  \  {{E _ {1}}  \left(  {x, \: y,
   \: z, \: t}  \right)}}  }

_Type: Expression(Integer)

Indeed, we can *test* the defining identity, e.g. for the first case:

   test(F * %F = dot(g,F,F)$M * volumeForm(g)$M)

   \mathtt{true}

_Type: Boolean


4.3 Some Examples from *Maple*
==============================

Examples from Maple.


4.3.1 5-dimensional Manifold
----------------------------

First create a 5-dimensional manifold M and define a metric tensor g
on the tangent space of M:

   v:=[x[j] for j in 1..5]
   M:=DFORM(INT,v)
   g:=diagonalMatrix([1,1,1,1,1])::SquareMatrix(5,INT)
   dX:=baseForms()$M

   hodgeStar(g,dX.1)$M

   {dx _ {2}} \  {dx \_ {3}} \  {dx _ {4}} \  {dx _ {5}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3],x[4],x[5]])

   hodgeStar(g,dX.2)$M

   -{{dx _ {1}} \  {dx _ {3}} \  {dx _ {4}} \  {dx _ {5}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3],x[4],x[5]])

   hodgeStar(g,dX.2*dX.3)$M

   {dx _ {1}} \  {dx _ {4}} \  {dx _ {5}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3],x[4],x[5]])

   hodgeStar(g,dX.2*dX.4)$M

   -{{dx _ {1}} \  {dx _ {3}} \  {dx _ {5}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3],x[4],x[5]])

   hodgeStar(g,dX.2*dX.3*dX.4)$M

   -{{dx _ {1}} \  {dx _ {5}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3],x[4],x[5]])

We see an exact match with the published results.


4.3.2 General metric (2-dim)
----------------------------

To show the dependence of the Hodge star operator upon the metric, we
consider a general metric g on a 2-dimensional manifold.

   v:=[x,y]
   M:=DFORM(INT,v)
   R ==> EXPR INT
   g:=matrix([[a::R,b],[b,c]])::SquareMatrix(2,R)
   [dx,dy]:=baseForms()$M

   hodgeStar(g,dx)$M

   {{{c \  {\sqrt {{abs \left( {{{a \  c} -{{b} ^ {2}}}} \right)}}}}
   \over {{a \  c} -{{b} ^ {2}}}} \  dy}+{{{b \  {\sqrt {{abs \left(
   {{{a \  c} -{{b} ^ {2}}}} \right)}}}} \over {{a \  c} -{{b} ^
   {2}}}} \  dx}

_Type: DeRhamComplex(Integer,[x,y])

   hodgeStar(g,dy)$M

   -{{{b \  {\sqrt {{abs \left( {{{a \  c} -{{b} ^ {2}}}} \right)}}}}
   \over {{a \  c} -{{b} ^ {2}}}} \  dy} -{{{a \  {\sqrt {{abs \left(
   {{{a \  c} -{{b} ^ {2}}}} \right)}}}} \over {{a \  c} -{{b} ^
   {2}}}} \  dx}

_Type: DeRhamComplex(Integer,[x,y])

   f := hodgeStar(g,dx*dy)$M

   {\sqrt {{abs  \left(  {{{a \  c} -{{b} ^ {2}}}}  \right)}}}  \over
   {{a \  c} -{{b} ^ {2}}}

_Type: DeRhamComplex(Integer,[x,y])

   hodgeStar(g,f)$M

   {{abs \left( {{{a \  c} -{{b} ^ {2}}}} \right)} \over {{a \  c}
   -{{b} ^ {2}}}} \  dx \  dy

_Type: DeRhamComplex(Integer,[x,y])


4.3.3 Laplacian
---------------

The Laplacian of a function with respect to a metric g can be
calculated using the exterior derivative and the Hodge star operator.
Generally, the following identity holds:

   \Delta = d \circ \delta + \delta \circ d

where \delta:=(-1)^p\, \star^{-1}\,d \,\star is the **codifferential**
to be applied on a p-form (resulting in a (p-1)-form). Therefore, the
Laplacian applied to a function f (zero form) is:

   \Delta f = \delta \circ df = \star^{-1}\, d \,\star df= \star\, d
   \, \star df.

   v:=[r,u]  -- polar coordinates
   M:=DFORM(INT,v)
   R ==> EXPR INT
   g:=matrix([[1,0],[0,r^2]])::SquareMatrix(2,R)
   [dr,du]:=baseForms()$M

A function on M can easiliy be defined by

   f:=zeroForm(f)$M

   f\left({r, \: u}\right)

_Type: DeRhamComplex(Integer,[r,u])

We translate the formula:

   hodgeStar(g, d hodgeStar(g,d f)$M)$M

   {{{abs \left( {{{r} ^ {2}}} \right)} \  {{f _ {{{,2}{,2}}}} \left(
   {r, \: u} \right)}}+{{{r} ^ {2}} \  {abs \left( {{{r} ^ {2}}}
   \right)} \  {{f _ {{{,1}{,1}}}} \left( {r, \: u} \right)}}+{r \
   {abs \left( {{{r} ^ {2}}} \right)} \  {{f _ {{,1}}} \left( {r, \:
   u} \right)}}} \over {{r} ^ {4}}

_Type: DeRhamComplex(Integer,[r,u])

Simplifying yields for M:

   \Delta_M f = \frac{\partial^2 f}{\partial r^2} +
   \frac{1}{r} \frac{\partial f}{\partial r} +
   \frac{1}{r^2} \frac{\partial^2 f}{\partial u^2}


4.3.4 Lie derivative
--------------------

   v:=[x[i] for i in 1..3]
   M:=DFORM(INT,v)
   dX:=baseForms()$M
   V:=vectorField(V)$M
   f:=scalarField(f)$M

   lieDerivative(V,dX.1)

   \small{ {{{{V _ {1}} _ {{,3}}} \left( {{x _ {1}}, \: {x _ {2}}, \:
   {x _ {3}}} \right)} \  {dx _ {3}}}+{{{{V _ {1}} _ {{,2}}} \left(
   {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {dx _
   {2}}}+{{{{V _ {1}} _ {{,1}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x
   _ {3}}} \right)} \  {dx _ {1}}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3]])

   lieDerivative(V,f*dX.1)

   \small{ {{f \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}
   \  {{{V _ {1}} _ {{,3}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _
   {3}}} \right)} \  {dx _ {3}}}+{{f \left( {{x _ {1}}, \: {x _ {2}},
   \: {x _ {3}}} \right)} \  {{{V _ {1}} _ {{,2}}} \left( {{x _ {1}},
   \: {x _ {2}}, \: {x _ {3}}} \right)} \  {dx _ {2}}}+ \\ {{\left(
   {{{V _ {1}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}
   \  {{f _ {{,1}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)}}+{{{V _ {2}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _
   {3}}} \right)} \  {{f _ {{,2}}} \left( {{x _ {1}}, \: {x _ {2}}, \:
   {x _ {3}}} \right)}}+ \\ {{{V _ {3}} \left( {{x _ {1}}, \: {x _
   {2}}, \: {x _ {3}}} \right)} \  {{f _ {{,3}}} \left( {{x _ {1}}, \:
   {x _ {2}}, \: {x _ {3}}} \right)}}+{{f \left( {{x _ {1}}, \: {x _
   {2}}, \: {x _ {3}}} \right)} \  {{{V _ {1}} _ {{,1}}} \left( {{x _
   {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}} \right)} \  {dx _
   {1}}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3]])

   lieDerivative(V,f*dX.1*dX.2)

   \small{ -{{f \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)} \  {{{V _ {1}} _ {{,3}}} \left( {{x _ {1}}, \: {x _ {2}},
   \: {x _ {3}}} \right)} \  {dx _ {2}} \  {dx _ {3}}}+{{f \left( {{x
   _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {{{V _ {2}} _
   {{,3}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \
   {dx _ {1}} \  {dx _ {3}}}+ \\ {{\left( {{{V _ {1}} \left( {{x _
   {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {{f _ {{,1}}} \left(
   {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}}+{{{V _ {2}}
   \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)} \  {{f _
   {{,2}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}} \right)}}+
   \\ {{{V _ {3}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)} \  {{f _ {{,3}}} \left( {{x _ {1}}, \: {x _ {2}}, \: {x _
   {3}}} \right)}}+{{f \left( {{x _ {1}}, \: {x _ {2}}, \: {x _ {3}}}
   \right)} \  {{{V _ {2}} _ {{,2}}} \left( {{x _ {1}}, \: {x _ {2}},
   \: {x _ {3}}} \right)}}+ \\ {{f \left( {{x _ {1}}, \: {x _ {2}}, \:
   {x _ {3}}} \right)} \  {{{V _ {1}} _ {{,1}}} \left( {{x _ {1}}, \:
   {x _ {2}}, \: {x _ {3}}} \right)}} \right)} \  {dx _ {1}} \  {dx _
   {2}}}}

_Type: DeRhamComplex(Integer,[x[1],x[2],x[3]])

