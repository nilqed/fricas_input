)abbrev domain PROP Proposition
++ Author: Kurt Pagani
++ Date Created: Mon Jan 18 17:32:02 CET 2016
++ License: BSD
++ References:
++ Description:
++
Proposition(R) : Exports == Implementation where

  R:Join(Ring, Comparable)

  X   ==> Expression R
  IF  ==> InputForm
  OF  ==> OutputForm
  SY  ==> Symbol

  SEX ==> SExpression
  
  
  Exports == Join(CoercibleTo OF, ConvertibleTo IF) with 

    _/_\  : (%,%) -> %
    _\_/  : (%,%) -> %
    _>_>  : (%,%) -> %
    _~    :  %    -> %
    _^    : (%,%) -> %
    _<_<  : (%,%) -> %
    
    all   : (X,%) -> %
    ex    : (X,%) -> %
    
    all   : (List X,%) -> %
    ex    : (List X,%) -> %
      
    _=    : (X,X) -> %
    _<    : (X,X) -> %
    _>    : (X,X) -> %
    _>_=  : (X,X) -> %
    _<_=  : (X,X) -> %
    
    
    pred  : (Symbol,List X) -> %
    true  : () -> %
    false : () -> %
    
    
    assume  : % -> SEX
    assert  : % -> SEX
    prove   : % -> SEX
    prove   : (%,List %) -> SEX


    runTimeLimit   : PositiveInteger -> PositiveInteger
    runTimeLimit?  : () -> SEX

    useResolution  : Boolean -> Boolean
    useResolution? : () -> Boolean

    useHyperResolution  : Boolean -> Boolean
    useHyperResolution? : () -> Boolean
    
    useParaModulation  : Boolean -> Boolean
    useParaModulation? : () -> Boolean
    

  Implementation == SEX  add 
  

    Rep:=SEX


    if X has ConvertibleTo(IF) then

      x /\ y == CONJUNCTION(x,y)$Lisp
      x \/ y == DISJUNCTION(x,y)$Lisp
      x >> y == IMPLICATION(x,y)$Lisp
      x ^  y == EQUIVALENCE(x,y)$Lisp
      x << y == IMPLIED_BY(x,y)$Lisp
      ~ x    == NEGATION(x)$Lisp


      all(lx:List X, y:%):% ==
        xx:IF:=convert(lx)@IF
        ALLQUANT(cdr xx,y)$Lisp
        
        
      ex(lx:List X, y:%):% ==
        xx:IF:=convert(lx)@IF
        EXQUANT(cdr xx,y)$Lisp
        

      all(x:X,y:%):% == all([x],y)
       
      ex (x:X,y:%):% == ex([x],y)
        

      pred(s:Symbol, lx:List X):% ==
        xx:IF:=convert(lx)@IF
        PREDICATE(s,cdr xx)$Lisp
        
      true()  == TRUESYM()$Lisp
      false() == FALSESYM()$Lisp

      assume(x) == ASSUME(x)$Lisp
      assert(x) == ASSUME(x)$Lisp
      prove(x) == PROVE(x)$Lisp
      
      prove(x,y) == 
        a:List(SEX):=[assert s for s in y]
        prove x
 
      t = s ==
        tt:IF:=convert(t)$X
        ss:IF:=convert(s)$X 
        EQLTERM(tt,ss)$Lisp
        
      t < s ==
        tt:IF:=convert(t)$X
        ss:IF:=convert(s)$X 
        LTTERM(tt,ss)$Lisp        

      t > s ==
        tt:IF:=convert(t)$X
        ss:IF:=convert(s)$X 
        GTTERM(tt,ss)$Lisp
        
      t <= s ==
        tt:IF:=convert(t)$X
        ss:IF:=convert(s)$X 
        LEQTERM(tt,ss)$Lisp

      t >= s ==
        tt:IF:=convert(t)$X
        ss:IF:=convert(s)$X 
        GEQTERM(tt,ss)$Lisp
   

    -- Options
    b2l(b:Boolean):Symbol == if b then "T"::Symbol else NIL::Symbol

    runTimeLimit(t) == RUN_-TIME_-LIMIT(t)$Lisp
    runTimeLimit?() == RUN_-TIME_-LIMIT?()$Lisp
    
    useResolution(b) == USE_-RESOLUTION(b2l b)$Lisp
    useResolution?() == USE_-RESOLUTION?()$Lisp
    
    useHyperResolution(b) == USE_-HYPERRESOLUTION(b2l b)$Lisp
    useHyperResolution?() == USE_-HYPERRESOLUTION?()$Lisp
    
    useParaModulation(b) == USE_-PARAMODULATION(b2l b)$Lisp
    useParaModulation?() == USE_-PARAMODULATION?()$Lisp
      
    